/*
 * wrbmp.c
 *
 * This file was part of the Independent JPEG Group's software:
 * Copyright (C) 1994-1996, Thomas G. Lane.
 * libjpeg-turbo Modifications:
 * Copyright (C) 2013, Linaro Limited.
 * Copyright (C) 2014-2015, 2017, 2019, D. R. Commander.
 * For conditions of distribution and use, see the accompanying README.ijg
 * file.
 *
 * This file contains routines to write output images in Microsoft "BMP"
 * format (MS Windows 3.x and OS/2 1.x flavors).
 * Either 8-bit colormapped or 24-bit full-color format can be written.
 * No compression is supported.
 *
 * These routines may need modification for non-Unix environments or
 * specialized applications.  As they stand, they assume output to
 * an ordinary stdio stream.
 *
 * This code contributed by James Arthur Boucher.
 */

#include "cmyk.h"
#include "cdjpeg.h"             /* Common decls for cjpeg/djpeg applications */
#include "jconfigint.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define UNI_LOGF(f, x... ) \
  do { \
    if (f) \
      fprintf(f, x); \
      fflush(f);     \
  } while (0)

// Begin data structures
typedef unsigned long long u64;

struct uni_klee_node {
  u64 addr;
  u64 base;
  u64 size;
  u64 value;
};

struct uni_klee_vector {
  u64 size;
  u64 capacity;
  struct uni_klee_node *data;
};

struct uni_klee_arg {
  int index;
  u64 value;
  u64 size;
  char is_ptr;
  char name[256];
};

struct uni_klee_flat_map {
  int *keys;
  struct uni_klee_arg *values;
  u64 size;
};

struct uni_klee_key_value_pair {
  u64 key;
  struct uni_klee_node value;
  struct uni_klee_hash_map *map;
  struct uni_klee_key_value_pair *next;
};

struct uni_klee_hash_map {
  u64 size;
  u64 table_size;
  struct uni_klee_key_value_pair **table;
};
// End data structures

// Hash map for storing graph data from file
static struct uni_klee_vector *uni_klee_ptr_edges = NULL;
static struct uni_klee_hash_map *uni_klee_ptr_hash_map = NULL;
static struct uni_klee_hash_map *uni_klee_base_hash_map = NULL;
static struct uni_klee_flat_map *uni_klee_start_points_map = NULL;
static struct uni_klee_hash_map *uni_klee_sym_val_map = NULL;

static struct uni_klee_vector *uni_klee_vector_create(u64 cap) {
  struct uni_klee_vector *vector = (struct uni_klee_vector *)malloc(sizeof(struct uni_klee_vector));
  vector->size = 0;
  vector->capacity = cap;
  vector->data = (struct uni_klee_node *)malloc(sizeof(struct uni_klee_node) * cap);
  memset(vector->data, 0, sizeof(struct uni_klee_node) * cap);
  return vector;
}

static void uni_klee_vector_push_back(struct uni_klee_vector *vector, struct uni_klee_node node) {
  if (vector->size >= vector->capacity) {
    vector->capacity *= 2;
    vector->data = (struct uni_klee_node *)realloc(vector->data, sizeof(struct uni_klee_node) * vector->capacity);
  }
  vector->data[vector->size++] = node;
}

static struct uni_klee_node *uni_klee_vector_get(struct uni_klee_vector *vector, u64 index) {
  if (index >= vector->size) {
    return NULL;
  }
  return &vector->data[index];
}

static struct uni_klee_node *uni_klee_vector_get_back(struct uni_klee_vector *vector) {
  if (vector->size == 0) {
    return NULL;
  }
  return &vector->data[vector->size - 1];
}

static void uni_klee_vector_pop(struct uni_klee_vector *vector) {
  if (vector->size == 0) {
    return;
  }
  vector->data[vector->size - 1] = (struct uni_klee_node){0, 0, 0, 0};
  vector->size--;
}

static u64 uni_klee_vector_size(struct uni_klee_vector *vector) {
  return vector->size;
}

static void uni_klee_vector_free(struct uni_klee_vector *vector) {
  free(vector->data);
  free(vector);
}

static struct uni_klee_hash_map *uni_klee_hash_map_create(u64 cap) {
  struct uni_klee_hash_map *hash_map = (struct uni_klee_hash_map *)malloc(sizeof(struct uni_klee_hash_map));
  hash_map->size = 0;
  hash_map->table_size = cap;
  hash_map->table = (struct uni_klee_key_value_pair **)malloc(sizeof(struct uni_klee_key_value_pair *) * cap);
  memset(hash_map->table, 0, sizeof(struct uni_klee_key_value_pair *) * cap);
  return hash_map;
}

static u64 uni_klee_hash_map_fit(u64 key, u64 table_size) {
  return key % table_size;
}

static void uni_klee_hash_map_resize(struct uni_klee_hash_map *map) {
  u64 new_table_size = map->table_size * 2;
  struct uni_klee_key_value_pair **new_table = (struct uni_klee_key_value_pair **)malloc(sizeof(struct uni_klee_key_value_pair*) * new_table_size);
  memset(new_table, 0, sizeof(struct uni_klee_key_value_pair *) * new_table_size);
  for (u64 i = 0; i < map->table_size; i++) {
    struct uni_klee_key_value_pair *pair = map->table[i];
    while (pair != NULL) {
      struct uni_klee_key_value_pair *next = pair->next;
      u64 new_index = uni_klee_hash_map_fit(pair->key, new_table_size);
      pair->next = new_table[new_index];
      new_table[new_index] = pair;
      pair = next;
    }
  }
  free(map->table);
  map->table = new_table;
  map->table_size = new_table_size;
}

static void uni_klee_hash_map_insert(struct uni_klee_hash_map *map, u64 key, struct uni_klee_node value) {
  u64 index = uni_klee_hash_map_fit(key, map->table_size);
  struct uni_klee_key_value_pair *pair = map->table[index];
  while (pair != NULL) {
    if (pair->key == key) {
      // Replace the value if already exists
      pair->value = value;
      return;
    }
    pair = pair->next;
  }
  // Insert a new pair
  struct uni_klee_key_value_pair *new_pair = (struct uni_klee_key_value_pair *)malloc(sizeof(struct uni_klee_key_value_pair));
  new_pair->key = key;
  new_pair->value = value;
  new_pair->map = NULL;
  new_pair->next = map->table[index];
  map->table[index] = new_pair;
  map->size++;
  if (map->size > map->table_size * 2) {
    uni_klee_hash_map_resize(map);
  }
}


static void uni_klee_hash_map_insert_base(struct uni_klee_hash_map *map, u64 key, struct uni_klee_node value) {
  u64 index = uni_klee_hash_map_fit(key, map->table_size);
  struct uni_klee_key_value_pair *pair = map->table[index];
  while (pair != NULL) {
    if (pair->key == key) {
      if (pair->map == NULL) {
        pair->value = (struct uni_klee_node){0, 0, 0, 0};
        pair->map = uni_klee_hash_map_create(8);
      }
      UNI_LOGF(stderr, "Insert base address for the same key %llu - v %llu s %d\n", key, value.addr, pair->map->size);
      uni_klee_hash_map_insert(pair->map, value.addr, value);
      return;
    }
    pair = pair->next;
  }
  // Insert a new pair
  UNI_LOGF(stderr, "Insert base address for key %llu - v %llu\n", key, value.addr);
  struct uni_klee_key_value_pair *new_pair = (struct uni_klee_key_value_pair *)malloc(sizeof(struct uni_klee_key_value_pair));
  new_pair->key = key;
  new_pair->value = (struct uni_klee_node){0, 0, 0, 0};
  new_pair->map = uni_klee_hash_map_create(8);
  new_pair->next = map->table[index];
  map->table[index] = new_pair;
  map->size++;
  uni_klee_hash_map_insert(new_pair->map, value.addr, value);
  if (map->size > map->table_size * 2) {
    uni_klee_hash_map_resize(map);
  }
}

static struct uni_klee_key_value_pair *uni_klee_hash_map_get(struct uni_klee_hash_map *map, u64 key) {
  u64 index = uni_klee_hash_map_fit(key, map->table_size);
  struct uni_klee_key_value_pair *pair = map->table[index];
  while (pair != NULL) {
    if (pair->key == key) {
      return pair;
    }
    pair = pair->next;
  }
  return NULL;
}

static void uni_klee_hash_map_free(struct uni_klee_hash_map *map) {
  for (u64 i = 0; i < map->table_size; i++) {
    struct uni_klee_key_value_pair *pair = map->table[i];
    while (pair != NULL) {
      struct uni_klee_key_value_pair *next = pair->next;
      free(pair);
      pair = next;
    }
  }
  free(map->table);
  free(map);
}

static struct uni_klee_flat_map *uni_klee_flat_map_create(u64 size) {
  struct uni_klee_flat_map *flat_map = (struct uni_klee_flat_map *)malloc(sizeof(struct uni_klee_flat_map));
  flat_map->keys = (int *)malloc(sizeof(int) * (size + 1));
  flat_map->values = (struct uni_klee_arg *)malloc(sizeof(struct uni_klee_arg) * (size + 1));
  for (u64 i = 0; i < size; i++) {
    flat_map->keys[i] = -1;
  }
  memset(flat_map->values, 0, sizeof(struct uni_klee_arg) * (size + 1));
  flat_map->size = size;
  return flat_map;
}

static void uni_klee_flat_map_insert(struct uni_klee_flat_map *flat_map, int key, struct uni_klee_arg* value) {
  for (u64 i = 0; i < flat_map->size; i++) {
    if (flat_map->keys[i] < 0) {
      fprintf(stderr, "Inserting key %d at index %llu - value %llu size %llu is_ptr %d name %s\n", key, i, value->value, value->size, value->is_ptr, value->name);
      flat_map->keys[i] = key;
      memcpy(&flat_map->values[i], value, sizeof(struct uni_klee_arg));
      return;
    }
  }
}

static struct uni_klee_arg *uni_klee_flat_map_get(struct uni_klee_flat_map *flat_map, int key) {
  for (u64 i = 0; i < flat_map->size; i++) {
    if (flat_map->keys[i] < 0) {
      return NULL;
    }
    if (flat_map->keys[i] == key) {
      return &flat_map->values[i];
    }
  }
  return NULL;
}

static void uni_klee_initialize_hash_map(int n) {
  // Initialize the hash map
  char *base_file = getenv("UNI_KLEE_MEM_BASE_FILE");
  char *mem_file = getenv("UNI_KLEE_MEM_FILE");
  if (base_file == NULL || mem_file == NULL)
    return;
  uni_klee_ptr_edges = uni_klee_vector_create(128);
  uni_klee_ptr_hash_map = uni_klee_hash_map_create(128);
  uni_klee_base_hash_map = uni_klee_hash_map_create(128);
  uni_klee_start_points_map = uni_klee_flat_map_create(n);
  uni_klee_sym_val_map = uni_klee_hash_map_create(32);
  FILE *base_fp = fopen(base_file, "r");
  FILE *mem_fp = fopen(mem_file, "r");
  if (base_fp == NULL || mem_fp == NULL)
    return;
  size_t len = 1024;
  char line[1024];
  while (fgets(line, len, base_fp) != NULL) {
    struct uni_klee_node node = {0, 0, 0, 0};
    if(strstr(line, "[node]") != NULL) {
      sscanf(line, "[node] [addr %llu] [base %llu] [size %llu] [value %llu]",
            &node.addr, &node.base, &node.size, &node.value);
      uni_klee_hash_map_insert(uni_klee_ptr_hash_map, node.addr, node);
      uni_klee_hash_map_insert_base(uni_klee_base_hash_map, node.base, node);
    } else if(strstr(line, "[start]") != NULL) {
      struct uni_klee_arg arg = {.index=0, .value=0, .size=0, .is_ptr=1, .name={0}};
      sscanf(line, "[start] [ptr %llu] [name %[^]]] [index %d]", &arg.value, arg.name, &arg.index);
      uni_klee_flat_map_insert(uni_klee_start_points_map, arg.index, &arg);
    }
  }
  // Update memory graph for each symbolic input
  while (fgets(line, len, mem_fp) != NULL) {
    struct uni_klee_node node = {0, 0, 0, 0};
    if(strstr(line, "[node]") != NULL) {
      sscanf(line, "[node] [addr %llu] [base %llu] [size %llu] [value %llu]",
            &node.addr, &node.base, &node.size, &node.value);
      uni_klee_hash_map_insert(uni_klee_ptr_hash_map, node.addr, node);
      uni_klee_hash_map_insert_base(uni_klee_base_hash_map, node.base, node);
    } else if (strstr(line, "[sym] [arg]") != NULL) {
      struct uni_klee_arg arg = {.index=0, .value=0, .size=0, .is_ptr=0, .name={0}};
      sscanf(line, "[sym] [arg] [index %d] [size %llu] [name %[^]]]",
            &arg.index, &arg.size, arg.name);
      uni_klee_flat_map_insert(uni_klee_start_points_map, arg.index, &arg);
    } else if (strstr(line, "[sym] [heap]") != NULL) {
      char symType[16];
      char name[256];
      sscanf(line, "[sym] [heap] [type %[^]]] [addr %llu] [base %llu] [size %llu] [name %[^]]]",
            symType, &node.addr, &node.base, &node.size, name);
      // There are "heap", "sym_ptr", "lazy", "patch" - ignore sym_ptr (already handled) and patch
      if (strstr(symType, "sym_ptr") != NULL || strstr(symType, "patch") != NULL) {
        continue;
      } else {
        uni_klee_hash_map_insert(uni_klee_sym_val_map, node.addr, node);
        struct uni_klee_key_value_pair *pair = uni_klee_hash_map_get(uni_klee_sym_val_map, node.addr);
        // HACK: store the name in the map field
        pair->map = malloc(sizeof(char) * 256);
        strcpy((char *)pair->map, name);
      }
    }
  }
  // Generate the edge list
  for (u64 i = 0; i < uni_klee_ptr_hash_map->table_size; i++) {
    struct uni_klee_key_value_pair *pair = uni_klee_ptr_hash_map->table[i];
    while (pair != NULL) {
      uni_klee_vector_push_back(uni_klee_ptr_edges, pair->value);
      pair = pair->next;
    }
  }
  // Close the file
  fclose(base_fp);
  fclose(mem_fp);
}

static char *uni_klee_hex_string(char *value, u64 size) {
  char *result = malloc(2 * size + 1);
  for (u64 i = 0; i < size; i++) {
    sprintf(result + 2 * i, "%02x", (unsigned char)value[i]);
  }
  result[2 * size] = '\0';
  return result;
}

void uni_klee_heap_check(u64 *start_points, int n) {
  char *result_file = getenv("UNI_KLEE_MEM_RESULT");
  if (result_file == NULL)
    return;
  if (uni_klee_ptr_edges == NULL) {
    uni_klee_initialize_hash_map(n);
  }
  if (uni_klee_ptr_edges == NULL || uni_klee_ptr_hash_map == NULL || uni_klee_base_hash_map == NULL || uni_klee_start_points_map == NULL)
    return;
  FILE *result_fp = fopen(result_file, "a");
  if (result_fp == NULL)
    return;
  UNI_LOGF(result_fp, "[heap-check] [begin]\n");
  // Build the hash map for matching the uni-klee address to actual address
  // Hash map for matching the uni-klee address to actual address
  // First, complete the uni-klee to real address mapping && real address to uni-klee mapping
  struct uni_klee_hash_map *u2a_hash_map = uni_klee_hash_map_create(1024);
  struct uni_klee_hash_map *u2a_value_map = uni_klee_hash_map_create(1024);
  struct uni_klee_vector *u2a_queue = uni_klee_vector_create(16);
  for (int i = 0; i < n; i++) {
    void *start_point = start_points[i];
    struct uni_klee_arg *arg = uni_klee_flat_map_get(uni_klee_start_points_map, i);
    if (arg == NULL) {
      UNI_LOGF(result_fp, "[arg] [err-no-info] [index %d] [value %llu]\n", i, (u64)start_point);
      continue;
    }
    UNI_LOGF(result_fp, "[mem] [index %d] [u-addr %llu] [a-addr %llu]\n", i, (u64)arg->value, (u64)start_point);
    if (!arg->is_ptr && arg->size <= 8) {
      u64 tmp = (u64)start_point;
      char *hex = uni_klee_hex_string((char *)&tmp, arg->size);
      UNI_LOGF(result_fp, "[val] [arg] [index %d] [value %s] [size %llu] [name %s] [num %llu]\n", arg->index, hex, arg->size, arg->name, tmp);
      free(hex);
      continue;
    }
    void *value = NULL;
    if (start_point != NULL) { // Check if the pointer is NULL
      value = *(void **)start_point; // Read the value from the pointer
    }
    struct uni_klee_node actual_node = {(u64)start_point, 0, 0, (u64)value};
    struct uni_klee_key_value_pair *kv_pair = uni_klee_hash_map_get(u2a_hash_map, arg->value);
    if (kv_pair != NULL) {
      // Address already treated
      continue;
    }
    fprintf(stderr, "[u2a-map] [insert] [u-val %llu] [a-addr %llu] [a-val %llu]\n", arg->value, (u64)start_point, (u64)value);
    uni_klee_hash_map_insert(u2a_hash_map, arg->value, actual_node);
    uni_klee_vector_push_back(u2a_queue, (struct uni_klee_node){arg->value, 0, 0, (u64)start_point});
    while (uni_klee_vector_size(u2a_queue) > 0) {
      struct uni_klee_node *node = uni_klee_vector_get_back(u2a_queue);
      u64 u_addr = node->addr;
      u64 a_addr = node->value;
      u64 u_base = 0;
      u64 u_value = 0;
      uni_klee_vector_pop(u2a_queue);
      struct uni_klee_key_value_pair *pair = uni_klee_hash_map_get(uni_klee_ptr_hash_map, u_addr);
      struct uni_klee_key_value_pair *base_pair = uni_klee_hash_map_get(uni_klee_base_hash_map, u_addr);
      char is_base = base_pair != NULL;
      if (pair) {
        u_base = pair->value.base;
        u_value = pair->value.value;
      }
      u64 u_offset = u_base == 0 ? 0 : u_addr - u_base;
      fprintf(stderr, "[base] [u-addr %llu] [u-base %llu] [u-offset %llu] [u-value %llu] [a-addr %llu]\n", u_addr, u_base, u_offset, u_value, a_addr);
      if (!is_base) {
        base_pair = uni_klee_hash_map_get(uni_klee_base_hash_map, u_base);
        fprintf(stderr, "[force-base] [u-addr %llu] [u-base %llu] [u-offset %llu] [u-value %llu] [a-addr %llu]\n", u_addr, u_base, u_offset, u_value, a_addr);
      }
      char *a_base_ptr = (char *)(a_addr);
      if (base_pair) {
        // This is base address: check all outgoing pointers in object
        u64 ubase = base_pair->key;
        for (u64 i = 0; i < base_pair->map->table_size; i++) {
          // key: address from uni-klee
          // map: outgoing pointers from key
          struct uni_klee_key_value_pair *pair = base_pair->map->table[i];
          while (pair != NULL) {
            struct uni_klee_key_value_pair *a_pair = uni_klee_hash_map_get(u2a_hash_map, pair->key);
            u64 u_value = pair->value.value;
            struct uni_klee_key_value_pair *a_val_pair = uni_klee_hash_map_get(u2a_value_map, u_value);
            if (a_pair != NULL && a_val_pair != NULL) {
              fprintf(stderr, "[base-edge-fail] [u-addr %llu] [u-offset %llu] [a-addr %llu] [a-offset %llu]\n", pair->key, pair->value.addr - ubase, a_addr, (u64)a_base_ptr);
              pair = pair->next;
              continue;
            }
            u64 offset = pair->value.addr - ubase;
            fprintf(stderr, "[base-edge] [u-addr %llu] [u-offset %llu] [a-addr %llu] [a-offset %llu]\n", pair->key, offset, a_addr, (u64)a_base_ptr);
            if (a_base_ptr == NULL) {
              UNI_LOGF(result_fp, "[mem] [error] [null-pointer] [addr %llu] [base %llu] [offset %llu]\n", pair->value.addr, ubase, offset);
              continue;
            }
            char *a_ptr = a_base_ptr + offset;
            void *a_value = *(void **)a_ptr;
            UNI_LOGF(result_fp, "[mem] [mem-edge] [u-addr %llu] [u-offset %llu] [a-addr %llu] [a-value %llu]\n", pair->key, offset, (u64)a_ptr, (u64)a_value);
            struct uni_klee_node a_node = {(u64)a_ptr, (u64)(a_ptr - offset), 0, (u64)a_value};
            uni_klee_hash_map_insert(u2a_hash_map, pair->key, a_node);
            struct uni_klee_node a_value_node = {(u64)a_value, 0, 0, (u64)a_value};
            if (pair->value.value != 0) {
              fprintf(stderr, "[u2a] [insert] [u-val %llu] [a-val %llu]\n", pair->value.value, (u64)a_value);
              uni_klee_hash_map_insert(u2a_value_map, pair->value.value, a_value_node);
            }
            if (a_value != NULL)
              uni_klee_vector_push_back(u2a_queue, (struct uni_klee_node){pair->value.value, (u64)a_ptr, 0, (u64)a_value});
            pair = pair->next;
          }
        }
      } else {
        if (pair == NULL) {
          UNI_LOGF(result_fp, "[mem] [pass] [no-node] [u-addr %llu] [a-addr %llu]\n", u_addr, a_addr);
          continue;
        }
        u64 u_offset = u_addr - u_base;
        void *a_value = *(void **)a_addr;
        struct uni_klee_node a_node = {(u64)a_addr, (u64)(a_addr - u_offset), 0, (u64)a_value};
        UNI_LOGF(result_fp, "[mem] [ptr-edge] [u-addr %llu] [u-offset %llu] [a-addr %llu] [a-value %llu]\n", u_addr, u_offset, a_addr, (u64)a_value);
        uni_klee_hash_map_insert(u2a_hash_map, u_addr, a_node);
        fprintf(stderr, "[u2a] [insert] [u-val %llu] [a-val %llu]\n", u_value, (u64)a_value);
        if (a_value != NULL)
          uni_klee_vector_push_back(u2a_queue, (struct uni_klee_node){pair->value.value, (u64)a_addr, 0, (u64)a_value});
      }
    }
  }
  UNI_LOGF(result_fp, "[heap-check] [u2a-hash-map] [size %llu]\n", u2a_hash_map->size);
  for (u64 i = 0; i < uni_klee_vector_size(uni_klee_ptr_edges); i++) {
    struct uni_klee_node *node = uni_klee_vector_get(uni_klee_ptr_edges, i);
    u64 u_addr = node->addr;
    u64 u_value = node->value;
    struct uni_klee_key_value_pair *pair = uni_klee_hash_map_get(u2a_hash_map, u_addr);
    if (pair == NULL) {
      UNI_LOGF(result_fp, "[heap-check] [error] [no-mapping] [u-addr %llu] [u-value %llu]\n", u_addr, u_value);
      continue;
    }
    u64 a_addr = pair->value.addr;
    u64 a_value = pair->value.value;
    if (u_value == 1) { // Don't care about the value
      UNI_LOGF(result_fp, "[heap-check] [ok] [u-addr %llu] [u-value %llu] [a-addr %llu] [a-value %llu]\n", u_addr, u_value, a_addr, a_value);
      continue;
    }
    struct uni_klee_key_value_pair *u_value_pair = uni_klee_hash_map_get(uni_klee_ptr_hash_map, u_value);
    struct uni_klee_key_value_pair *a_value_pair = uni_klee_hash_map_get(u2a_hash_map, u_value);
    if (u_value_pair == NULL && a_value_pair == NULL) { // Both are not pointer of pointer
      if (u_value == NULL && a_value == NULL) {
        // OK
        UNI_LOGF(result_fp, "[heap-check] [ok] [u-addr %llu] [u-value %llu] [a-addr %llu] [a-value %llu]\n", u_addr, u_value, a_addr, a_value);
      } else if (u_value != NULL && a_value != NULL) {
        // Also OK
        UNI_LOGF(result_fp, "[heap-check] [ok] [u-addr %llu] [u-value %llu] [a-addr %llu] [a-value %llu]\n", u_addr, u_value, a_addr, a_value);
      } else {
        UNI_LOGF(result_fp, "[heap-check] [error] [value-mismatch] [u-addr %llu] [u-value %llu] [a-addr %llu] [a-value %llu]\n", u_addr, u_value, a_addr, a_value);
      }
    } else if (u_value_pair != NULL && a_value_pair != NULL) {
      u64 a_value_from_uni_klee = a_value_pair->value.addr;
      if (a_value != a_value_from_uni_klee) {
        UNI_LOGF(result_fp, "[heap-check] [error] [value-mismatch] [u-addr %llu] [u-value %llu] [a-addr %llu] [a-value %llu]\n", u_addr, u_value, a_addr, a_value);
      } else {
        UNI_LOGF(result_fp, "[heap-check] [ok] [u-addr %llu] [u-value %llu] [a-addr %llu] [a-value %llu]\n", u_addr, u_value, a_addr, a_value);
      }
    } else {
      UNI_LOGF(result_fp, "[heap-check] [error] [value-mismatch] [u-addr %llu] [u-value %llu] [a-addr %llu] [a-value %llu]\n", u_addr, u_value, a_addr, a_value);
    }
  }
  // Collect values from heap
  for (u64 i = 0; i < uni_klee_sym_val_map->table_size; i++) {
    struct uni_klee_key_value_pair *pair = uni_klee_sym_val_map->table[i];
    while (pair != NULL) {
      u64 u_addr = pair->key;
      // HACK: load the name from the map field
      char *name = (char *)pair->map;
      u64 u_base = pair->value.base;
      u64 size = pair->value.size;
      pair = pair->next;
      u64 a_addr = 0;
      struct uni_klee_key_value_pair *a_pair = uni_klee_hash_map_get(u2a_value_map, u_addr);
      if (a_pair == NULL) {
        // Search using u_base
        a_pair = uni_klee_hash_map_get(u2a_hash_map, u_base);
        if (a_pair == NULL) {
          UNI_LOGF(result_fp, "[val] [error] [no-mapping] [u-addr %llu] [name %s]\n", u_addr, name);
          continue;
        }
        a_addr = a_pair->value.addr + (u_addr - u_base);
      } else {
        a_addr = a_pair->value.addr;
      }
      if (a_addr == NULL) {
        UNI_LOGF(result_fp, "[val] [error] [null-pointer] [addr %llu] [name %s]\n", u_addr, name);
        continue;
      }
      char *a_base_ptr = (char *)a_addr;
      // Print the data as hex string
      char *hex = uni_klee_hex_string(a_base_ptr, size);
      u64 value = 0;
      if (size == 1) {
        unsigned char v = *(unsigned char *)a_base_ptr;
        value = (u64)v;
      } else if (size == 2) {
        unsigned short v = *(unsigned short *)a_base_ptr;
        value = (u64)v;
      } else if (size == 4) {
        unsigned int v = *(unsigned int *)a_base_ptr;
        value = (u64)v;
      } else if (size == 8) {
        value = *(u64 *)a_base_ptr;
      } else {
        value = *(u64 *)a_base_ptr;
      }
      UNI_LOGF(result_fp, "[val] [heap] [u-addr %llu] [name %s] [value %s] [size %llu] [num %llu]\n", u_addr, name, hex, size, value);
      free(hex);
    }
  }
  UNI_LOGF(result_fp, "[heap-check] [end]\n");
  fclose(result_fp);
  uni_klee_hash_map_free(u2a_hash_map);
  uni_klee_vector_free(u2a_queue);
}


#ifdef BMP_SUPPORTED


/*
 * To support 12-bit JPEG data, we'd have to scale output down to 8 bits.
 * This is not yet implemented.
 */

#if BITS_IN_JSAMPLE != 8
  Sorry, this code only copes with 8-bit JSAMPLEs. /* deliberate syntax err */
#endif

/*
 * Since BMP stores scanlines bottom-to-top, we have to invert the image
 * from JPEG's top-to-bottom order.  To do this, we save the outgoing data
 * in a virtual array during put_pixel_row calls, then actually emit the
 * BMP file during finish_output.  The virtual array contains one JSAMPLE per
 * pixel if the output is grayscale or colormapped, three if it is full color.
 */

/* Private version of data destination object */

typedef struct {
  struct djpeg_dest_struct pub; /* public fields */

  boolean is_os2;               /* saves the OS2 format request flag */

  jvirt_sarray_ptr whole_image; /* needed to reverse row order */
  JDIMENSION data_width;        /* JSAMPLEs per row */
  JDIMENSION row_width;         /* physical width of one row in the BMP file */
  int pad_bytes;                /* number of padding bytes needed per row */
  JDIMENSION cur_output_row;    /* next row# to write to virtual array */

  boolean use_inversion_array;  /* TRUE = buffer the whole image, which is
                                   stored to disk in bottom-up order, and
                                   receive rows from the calling program in
                                   top-down order

                                   FALSE = the calling program will maintain
                                   its own image buffer and write the rows in
                                   bottom-up order */

  JSAMPLE *iobuffer;            /* I/O buffer (used to buffer a single row to
                                   disk if use_inversion_array == FALSE) */
} bmp_dest_struct;

typedef bmp_dest_struct *bmp_dest_ptr;


/* Forward declarations */
LOCAL(void) write_colormap(j_decompress_ptr cinfo, bmp_dest_ptr dest,
                           int map_colors, int map_entry_size);


static INLINE boolean is_big_endian(void)
{
  int test_value = 1;
  if (*(char *)&test_value != 1)
    return TRUE;
  return FALSE;
}


/*
 * Write some pixel data.
 * In this module rows_supplied will always be 1.
 */

METHODDEF(void)
put_pixel_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
               JDIMENSION rows_supplied)
/* This version is for writing 24-bit pixels */
{
  bmp_dest_ptr dest = (bmp_dest_ptr)dinfo;
  JSAMPARRAY image_ptr;
  register JSAMPROW inptr, outptr;
  register JDIMENSION col;
  int pad;

  if (dest->use_inversion_array) {
    /* Access next row in virtual array */
    image_ptr = (*cinfo->mem->access_virt_sarray)
      ((j_common_ptr)cinfo, dest->whole_image,
       dest->cur_output_row, (JDIMENSION)1, TRUE);
    dest->cur_output_row++;
    outptr = image_ptr[0];
  } else {
    outptr = dest->iobuffer;
  }

  /* Transfer data.  Note destination values must be in BGR order
   * (even though Microsoft's own documents say the opposite).
   */
  inptr = dest->pub.buffer[0];

  if (cinfo->out_color_space == JCS_EXT_BGR) {
    MEMCOPY(outptr, inptr, dest->row_width);
    outptr += cinfo->output_width * 3;
  } else if (cinfo->out_color_space == JCS_RGB565) {
    boolean big_endian = is_big_endian();
    unsigned short *inptr2 = (unsigned short *)inptr;
    for (col = cinfo->output_width; col > 0; col--) {
      if (big_endian) {
        outptr[0] = (*inptr2 >> 5) & 0xF8;
        outptr[1] = ((*inptr2 << 5) & 0xE0) | ((*inptr2 >> 11) & 0x1C);
        outptr[2] = *inptr2 & 0xF8;
      } else {
        outptr[0] = (*inptr2 << 3) & 0xF8;
        outptr[1] = (*inptr2 >> 3) & 0xFC;
        outptr[2] = (*inptr2 >> 8) & 0xF8;
      }
      outptr += 3;
      inptr2++;
    }
  } else if (cinfo->out_color_space == JCS_CMYK) {
    for (col = cinfo->output_width; col > 0; col--) {
      /* can omit GETJSAMPLE() safely */
      JSAMPLE c = *inptr++, m = *inptr++, y = *inptr++, k = *inptr++;
      cmyk_to_rgb(c, m, y, k, outptr + 2, outptr + 1, outptr);
      outptr += 3;
    }
  } else {
    register int rindex = rgb_red[cinfo->out_color_space];
    register int gindex = rgb_green[cinfo->out_color_space];
    register int bindex = rgb_blue[cinfo->out_color_space];
    register int ps = rgb_pixelsize[cinfo->out_color_space];

    for (col = cinfo->output_width; col > 0; col--) {
      /* can omit GETJSAMPLE() safely */
      outptr[0] = inptr[bindex];
      outptr[1] = inptr[gindex];
      outptr[2] = inptr[rindex];
      outptr += 3;  inptr += ps;
    }
  }

  /* Zero out the pad bytes. */
  pad = dest->pad_bytes;
  while (--pad >= 0)
    *outptr++ = 0;

  if (!dest->use_inversion_array)
    (void)JFWRITE(dest->pub.output_file, dest->iobuffer, dest->row_width);
}

METHODDEF(void)
put_gray_rows(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo,
              JDIMENSION rows_supplied)
/* This version is for grayscale OR quantized color output */
{
  bmp_dest_ptr dest = (bmp_dest_ptr)dinfo;
  JSAMPARRAY image_ptr;
  register JSAMPROW inptr, outptr;
  int pad;

  if (dest->use_inversion_array) {
    /* Access next row in virtual array */
    image_ptr = (*cinfo->mem->access_virt_sarray)
      ((j_common_ptr)cinfo, dest->whole_image,
       dest->cur_output_row, (JDIMENSION)1, TRUE);
    dest->cur_output_row++;
    outptr = image_ptr[0];
  } else {
    outptr = dest->iobuffer;
  }

  /* Transfer data. */
  inptr = dest->pub.buffer[0];
  MEMCOPY(outptr, inptr, cinfo->output_width);
  outptr += cinfo->output_width;

  /* Zero out the pad bytes. */
  pad = dest->pad_bytes;
  while (--pad >= 0)
    *outptr++ = 0;

  if (!dest->use_inversion_array)
    (void)JFWRITE(dest->pub.output_file, dest->iobuffer, dest->row_width);
}


/*
 * Finish up at the end of the file.
 *
 * Here is where we really output the BMP file.
 *
 * First, routines to write the Windows and OS/2 variants of the file header.
 */

LOCAL(void)
write_bmp_header(j_decompress_ptr cinfo, bmp_dest_ptr dest)
/* Write a Windows-style BMP file header, including colormap if needed */
{
  char bmpfileheader[14];
  char bmpinfoheader[40];

#define PUT_2B(array, offset, value) \
  (array[offset] = (char)((value) & 0xFF), \
   array[offset + 1] = (char)(((value) >> 8) & 0xFF))
#define PUT_4B(array, offset, value) \
  (array[offset] = (char)((value) & 0xFF), \
   array[offset + 1] = (char)(((value) >> 8) & 0xFF), \
   array[offset + 2] = (char)(((value) >> 16) & 0xFF), \
   array[offset + 3] = (char)(((value) >> 24) & 0xFF))

  long headersize, bfSize;
  int bits_per_pixel, cmap_entries;

  /* Compute colormap size and total file size */
  if (IsExtRGB(cinfo->out_color_space)) {
    if (cinfo->quantize_colors) {
      /* Colormapped RGB */
      bits_per_pixel = 8;
      cmap_entries = 256;
    } else {
      /* Unquantized, full color RGB */
      bits_per_pixel = 24;
      cmap_entries = 0;
    }
  } else if (cinfo->out_color_space == JCS_RGB565 ||
             cinfo->out_color_space == JCS_CMYK) {
    bits_per_pixel = 24;
    cmap_entries   = 0;
  } else {
    /* Grayscale output.  We need to fake a 256-entry colormap. */
    bits_per_pixel = 8;
    cmap_entries = 256;
  }
  /* File size */
  headersize = 14 + 40 + cmap_entries * 4; /* Header and colormap */
  bfSize = headersize + (long)dest->row_width * (long)cinfo->output_height;

  /* Set unused fields of header to 0 */
  MEMZERO(bmpfileheader, sizeof(bmpfileheader));
  MEMZERO(bmpinfoheader, sizeof(bmpinfoheader));

  /* Fill the file header */
  bmpfileheader[0] = 0x42;      /* first 2 bytes are ASCII 'B', 'M' */
  bmpfileheader[1] = 0x4D;
  PUT_4B(bmpfileheader, 2, bfSize); /* bfSize */
  /* we leave bfReserved1 & bfReserved2 = 0 */
  PUT_4B(bmpfileheader, 10, headersize); /* bfOffBits */

  /* Fill the info header (Microsoft calls this a BITMAPINFOHEADER) */
  PUT_2B(bmpinfoheader, 0, 40); /* biSize */
  PUT_4B(bmpinfoheader, 4, cinfo->output_width); /* biWidth */
  PUT_4B(bmpinfoheader, 8, cinfo->output_height); /* biHeight */
  PUT_2B(bmpinfoheader, 12, 1); /* biPlanes - must be 1 */
  PUT_2B(bmpinfoheader, 14, bits_per_pixel); /* biBitCount */
  /* we leave biCompression = 0, for none */
  /* we leave biSizeImage = 0; this is correct for uncompressed data */
  if (cinfo->density_unit == 2) { /* if have density in dots/cm, then */
    PUT_4B(bmpinfoheader, 24, (long)(cinfo->X_density * 100)); /* XPels/M */
    PUT_4B(bmpinfoheader, 28, (long)(cinfo->Y_density * 100)); /* XPels/M */
  }
  PUT_2B(bmpinfoheader, 32, cmap_entries); /* biClrUsed */
  /* we leave biClrImportant = 0 */

  if (JFWRITE(dest->pub.output_file, bmpfileheader, 14) != (size_t)14)
    ERREXIT(cinfo, JERR_FILE_WRITE);
  if (JFWRITE(dest->pub.output_file, bmpinfoheader, 40) != (size_t)40)
    ERREXIT(cinfo, JERR_FILE_WRITE);

  if (cmap_entries > 0)
    write_colormap(cinfo, dest, cmap_entries, 4);
}


LOCAL(void)
write_os2_header(j_decompress_ptr cinfo, bmp_dest_ptr dest)
/* Write an OS2-style BMP file header, including colormap if needed */
{
  char bmpfileheader[14];
  char bmpcoreheader[12];
  long headersize, bfSize;
  int bits_per_pixel, cmap_entries;

  /* Compute colormap size and total file size */
  if (IsExtRGB(cinfo->out_color_space)) {
    if (cinfo->quantize_colors) {
      /* Colormapped RGB */
      bits_per_pixel = 8;
      cmap_entries = 256;
    } else {
      /* Unquantized, full color RGB */
      bits_per_pixel = 24;
      cmap_entries = 0;
    }
  } else if (cinfo->out_color_space == JCS_RGB565 ||
             cinfo->out_color_space == JCS_CMYK) {
    bits_per_pixel = 24;
    cmap_entries   = 0;
  } else {
    /* Grayscale output.  We need to fake a 256-entry colormap. */
    bits_per_pixel = 8;
    cmap_entries = 256;
  }
  /* File size */
  headersize = 14 + 12 + cmap_entries * 3; /* Header and colormap */
  bfSize = headersize + (long)dest->row_width * (long)cinfo->output_height;

  /* Set unused fields of header to 0 */
  MEMZERO(bmpfileheader, sizeof(bmpfileheader));
  MEMZERO(bmpcoreheader, sizeof(bmpcoreheader));

  /* Fill the file header */
  bmpfileheader[0] = 0x42;      /* first 2 bytes are ASCII 'B', 'M' */
  bmpfileheader[1] = 0x4D;
  PUT_4B(bmpfileheader, 2, bfSize); /* bfSize */
  /* we leave bfReserved1 & bfReserved2 = 0 */
  PUT_4B(bmpfileheader, 10, headersize); /* bfOffBits */

  /* Fill the info header (Microsoft calls this a BITMAPCOREHEADER) */
  PUT_2B(bmpcoreheader, 0, 12); /* bcSize */
  PUT_2B(bmpcoreheader, 4, cinfo->output_width); /* bcWidth */
  PUT_2B(bmpcoreheader, 6, cinfo->output_height); /* bcHeight */
  PUT_2B(bmpcoreheader, 8, 1);  /* bcPlanes - must be 1 */
  PUT_2B(bmpcoreheader, 10, bits_per_pixel); /* bcBitCount */

  if (JFWRITE(dest->pub.output_file, bmpfileheader, 14) != (size_t)14)
    ERREXIT(cinfo, JERR_FILE_WRITE);
  if (JFWRITE(dest->pub.output_file, bmpcoreheader, 12) != (size_t)12)
    ERREXIT(cinfo, JERR_FILE_WRITE);

  if (cmap_entries > 0)
    write_colormap(cinfo, dest, cmap_entries, 3);
}


/*
 * Write the colormap.
 * Windows uses BGR0 map entries; OS/2 uses BGR entries.
 */

LOCAL(void)
write_colormap(j_decompress_ptr cinfo, bmp_dest_ptr dest, int map_colors,
               int map_entry_size)
{
  JSAMPARRAY colormap = cinfo->colormap;
  int num_colors = cinfo->actual_number_of_colors;
  FILE *outfile = dest->pub.output_file;
  int i;

  if (colormap != NULL) {
    if (cinfo->out_color_components == 3) {
      /* Normal case with RGB colormap */
      for (i = 0; i < num_colors; i++) {
        putc(GETJSAMPLE(colormap[2][i]), outfile);
        putc(GETJSAMPLE(colormap[1][i]), outfile);
        putc(GETJSAMPLE(colormap[0][i]), outfile);
        if (map_entry_size == 4)
          putc(0, outfile);
      }
    } else {
      /* Grayscale colormap (only happens with grayscale quantization) */
      for (i = 0; i < num_colors; i++) {
        putc(GETJSAMPLE(colormap[0][i]), outfile);
        putc(GETJSAMPLE(colormap[0][i]), outfile);
        putc(GETJSAMPLE(colormap[0][i]), outfile);
        if (map_entry_size == 4)
          putc(0, outfile);
      }
    }
  } else {
    /* If no colormap, must be grayscale data.  Generate a linear "map". */
    for (i = 0; i < 256; i++) {
      putc(i, outfile);
      putc(i, outfile);
      putc(i, outfile);
      if (map_entry_size == 4)
        putc(0, outfile);
    }
  }
  /* Pad colormap with zeros to ensure specified number of colormap entries */
  if (i > map_colors)
    ERREXIT1(cinfo, JERR_TOO_MANY_COLORS, i);
  for (; i < map_colors; i++) {
    putc(0, outfile);
    putc(0, outfile);
    putc(0, outfile);
    if (map_entry_size == 4)
      putc(0, outfile);
  }
}


/*
 * Startup: write the file header unless the inversion array is being used.
 */

METHODDEF(void)
start_output_bmp(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  bmp_dest_ptr dest = (bmp_dest_ptr)dinfo;

  if (!dest->use_inversion_array) {
    /* Write the header and colormap */
    if (dest->is_os2)
      write_os2_header(cinfo, dest);
    else
      write_bmp_header(cinfo, dest);
  }
}


METHODDEF(void)
finish_output_bmp(j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)
{
  bmp_dest_ptr dest = (bmp_dest_ptr)dinfo;
  register FILE *outfile = dest->pub.output_file;
  JSAMPARRAY image_ptr;
  register JSAMPROW data_ptr;
  JDIMENSION row;
  register JDIMENSION col;
  cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;

  if (dest->use_inversion_array) {
    /* Write the header and colormap */
    if (dest->is_os2)
      write_os2_header(cinfo, dest);
    else
      write_bmp_header(cinfo, dest);

    /* Write the file body from our virtual array */
    for (row = cinfo->output_height; row > 0; row--) {
      if (progress != NULL) {
        progress->pub.pass_counter = (long)(cinfo->output_height - row);
        progress->pub.pass_limit = (long)cinfo->output_height;
        (*progress->pub.progress_monitor) ((j_common_ptr)cinfo);
      }
      image_ptr = (*cinfo->mem->access_virt_sarray)
        ((j_common_ptr)cinfo, dest->whole_image, row - 1, (JDIMENSION)1,
         FALSE);
      data_ptr = image_ptr[0];
      for (col = dest->row_width; col > 0; col--) {
        putc(GETJSAMPLE(*data_ptr), outfile);
        data_ptr++;
      }
    }
    if (progress != NULL)
      progress->completed_extra_passes++;
  }

  /* Make sure we wrote the output file OK */
  fflush(outfile);
  if (ferror(outfile))
    ERREXIT(cinfo, JERR_FILE_WRITE);
}


/*
 * The module selection routine for BMP format output.
 */
GLOBAL(djpeg_dest_ptr)
jinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2,
                boolean use_inversion_array)
{
  unsigned long long uni_klee_args[] = {cinfo, (unsigned long long)is_os2, (unsigned long long)use_inversion_array};
  uni_klee_heap_check(uni_klee_args, 3);
  bmp_dest_ptr dest;
  JDIMENSION row_width;

  /* Create module interface object, fill in method pointers */
  dest = (bmp_dest_ptr)
    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,
                                sizeof(bmp_dest_struct));
  dest->pub.start_output = start_output_bmp;
  dest->pub.finish_output = finish_output_bmp;
  dest->pub.calc_buffer_dimensions = NULL;
  dest->is_os2 = is_os2;
  fprintf(stderr, "\n[test] [quantize_colors %d] [out_color_space %d] [JCS_GRAYSCALE %d] [JCS_RGB565 %d] [JCS_CMYK %d]\n", cinfo->quantize_colors, cinfo->out_color_space, JCS_GRAYSCALE, JCS_RGB565, JCS_CMYK);

  if (cinfo->out_color_space == JCS_GRAYSCALE) {
    dest->pub.put_pixel_rows = put_gray_rows;
  } else if (IsExtRGB(cinfo->out_color_space)) {
    if (cinfo->quantize_colors)
      dest->pub.put_pixel_rows = put_gray_rows;
    else
      dest->pub.put_pixel_rows = put_pixel_rows;
  } else if (cinfo->out_color_space == JCS_RGB565 ||
             cinfo->out_color_space == JCS_CMYK) {
    dest->pub.put_pixel_rows = put_pixel_rows;
  } else {
    ERREXIT(cinfo, JERR_BMP_COLORSPACE);
  }

  /* Calculate output image dimensions so we can allocate space */
  jpeg_calc_output_dimensions(cinfo);

  /* Determine width of rows in the BMP file (padded to 4-byte boundary). */
  if (cinfo->out_color_space == JCS_RGB565) {
    row_width = cinfo->output_width * 2;
    dest->row_width = dest->data_width = cinfo->output_width * 3;
    while ((row_width & 3) != 0) row_width++;
  } else if (!cinfo->quantize_colors &&
             (IsExtRGB(cinfo->out_color_space) ||
              cinfo->out_color_space == JCS_CMYK)) {
    row_width = cinfo->output_width * cinfo->output_components;
    dest->row_width = dest->data_width = cinfo->output_width * 3;
  } else {
    row_width = cinfo->output_width * cinfo->output_components;
    dest->row_width = dest->data_width = row_width;
  }
  while ((dest->row_width & 3) != 0) dest->row_width++;
  dest->pad_bytes = (int)(dest->row_width - dest->data_width);


  if (use_inversion_array) {
    /* Allocate space for inversion array, prepare for write pass */
    dest->whole_image = (*cinfo->mem->request_virt_sarray)
      ((j_common_ptr)cinfo, JPOOL_IMAGE, FALSE,
       dest->row_width, cinfo->output_height, (JDIMENSION)1);
    dest->cur_output_row = 0;
    if (cinfo->progress != NULL) {
      cd_progress_ptr progress = (cd_progress_ptr)cinfo->progress;
      progress->total_extra_passes++; /* count file input as separate pass */
    }
  } else {
    dest->iobuffer = (JSAMPLE *)(*cinfo->mem->alloc_small)
      ((j_common_ptr)cinfo, JPOOL_IMAGE, dest->row_width);
  }
  dest->use_inversion_array = use_inversion_array;

  /* Create decompressor output buffer. */
  dest->pub.buffer = (*cinfo->mem->alloc_sarray)
    ((j_common_ptr)cinfo, JPOOL_IMAGE, row_width, (JDIMENSION)1);
  dest->pub.buffer_height = 1;

  return (djpeg_dest_ptr)dest;
}

#endif /* BMP_SUPPORTED */
