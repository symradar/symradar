[
 {
  "id": 0,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 /* Decode the line number information for UNIT. */ static struct line_info_table* decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash) { bfd *abfd = unit->abfd; struct line_info_table* table; bfd_byte *line_ptr; bfd_byte *line_end; struct line_head lh; unsigned int i, bytes_read, offset_size; char *cur_file, *cur_dir; unsigned char op_code, extended_op, adj_opcode; unsigned int exop_len; bfd_size_type amt; if (! read_section (abfd, &stash->debug_sections[debug_line], stash->syms, unit->line_offset, &stash->dwarf_line_buffer, &stash->dwarf_line_size)) return NULL; amt = sizeof (struct line_info_table); table = (struct line_info_table *) bfd_alloc (abfd, amt); if (table == NULL) return NULL; table->abfd = abfd; table->comp_dir = unit->comp_dir; table->num_files = 0; table->files = NULL; table->num_dirs = 0; table->dirs = NULL; table->num_sequences = 0; table->sequences = NULL; table->lcl_head = NULL; if (stash->dwarf_line_size < 16) { _bfd_error_handler (_(\"Dwarf Error: Line info section is too small (%Ld)\"), stash->dwarf_line_size); bfd_set_error (bfd_error_bad_value); return NULL; } line_ptr = stash->dwarf_line_buffer + unit->line_offset; line_end = stash->dwarf_line_buffer + stash->dwarf_line_size; /* Read in the prologue. */ lh.total_length = read_4_bytes (abfd, line_ptr, line_end); line_ptr += 4; offset_size = 4; if (lh.total_length == 0xffffffff) { lh.total_length = read_8_bytes (abfd, line_ptr, line_end); line_ptr += 8; offset_size = 8; } else if (lh.total_length == 0 && unit->addr_size == 8) { /* Handle (non-standard) 64-bit DWARF2 formats. */ lh.total_length = read_4_bytes (abfd, line_ptr, line_end); line_ptr += 4; offset_size = 8; } if (lh.total_length >",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> case DW_LNS_const_add_pc : if (lh.line_range == 0) goto line_fail;"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> += 4 ; if ( offset_size >= line_end - line_ptr ) { _bfd_error_handler ( ( \"Dwarf Error: Line info section is too small (%Ld)\", line_end - line_ptr ) ) ; bfd_set_error ( bfd_error_bad_value ) ; return NULL ; } <vul-start> += 4 ; if ( offset_size >= line_end - line_ptr ) { _bfd_error_handler ( ( \"Dwarf Error: Line info section is too small (%Ld)\", line_end - line_ptr ) ) ; bfd_set_error ( bfd_error_bad_value ) ; return NULL ; }\n"
 },
 {
  "id": 1,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 /* Process a CU or TU index. If DO_DISPLAY is true, print the contents. These sections are extensions for Fission. See http://gcc.gnu.org/wiki/DebugFissionDWP. */ static int process_cu_tu_index (struct dwarf_section *section, int do_display) { unsigned char *phdr = section->start; unsigned char *limit = phdr + section->size; unsigned char *phash; unsigned char *pindex; unsigned char *ppool; unsigned int version; unsigned int ncols = 0; unsigned int nused; unsigned int nslots; unsigned int i; unsigned int j; dwarf_vma signature_high; dwarf_vma signature_low; char buf[64]; /* PR 17512: file: 002-168123-0.004. */ if (phdr == NULL) { warn (_(\"Section %s is empty\\n\"), section->name); return 0; } /* PR 17512: file: 002-376-0.004. */ if (section->size < 24) { warn (_(\"Section %s is too small to contain a CU/TU header\\n\"), section->name); return 0; } SAFE_BYTE_GET (version, phdr, 4, limit); if (version >= 2) SAFE_BYTE_GET (ncols, phdr + 4, 4, limit); SAFE_BYTE_GET (nused, phdr + 8, 4, limit); SAFE_BYTE_GET (nslots, phdr + 12, 4, limit); phash = phdr + 16; pindex = phash + nslots * 8; ppool = pindex + nslots * 4; /* PR 17531: file: 45d69832. */ if (pindex < phash || ppool < phdr || (pindex == phash && nslots != 0)) { warn (ngettext (\"Section %s is too small for %d slot\\n\", \"Section %s",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> do_display ) { if ((ph + sizeof(uint64_t)) >= limit) return 0;"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> do_display ) { memcpy <vul-end> ( & this_set <vul-start> do_display ) { memcpy <vul-end> ( & this_set\n"
 },
 {
  "id": 2,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 int main (int argc, char **argv) { int limit; char *sieve; size_t size, i; struct prime *prime_list; unsigned nprimes; if (argc != 2) { fprintf (stderr, \"Usage: %s LIMIT\\n\" \"Produces a list of odd primes <= LIMIT\\n\", argv[0]); return EXIT_FAILURE; } limit = atoi (argv[1]); if (limit < 3) return EXIT_SUCCESS; /* Make limit odd */ if ( !(limit & 1)) limit--; size = (limit-1)/2; /* sieve[i] represents 3+2*i */ sieve = xalloc (size); memset (sieve, 1, size); prime_list = xalloc (size * sizeof (*prime_list)); nprimes = 0; for (i = 0; i < size;) { unsigned p = 3+2*i; unsigned j; process_prime (&prime_list[nprimes++], p); for (j = (p*p - 3)/2; j < size; j+= p) sieve[j] = 0; <vul-start>while (i < size && sieve[++i] == 0)<vul-end> ; } output_primes (prime_list, nprimes); if (ferror (stdout) + fclose (stdout)) { fprintf (stderr, \"write error: %s\\n\", strerror (errno)); return EXIT_FAILURE; } return EXIT_SUCCESS; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ; while ( ( i + 1 ) <vul-end> < size && "
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> = 0 ; if ( sieve [ j ] == 0 ) break ;\n"
 },
 {
  "id": 3,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 /* * Fill a buffer with a fixed pattern. * * The buffer must be at least 3 bytes long, even if * size is less. Larger sizes are filled exactly. */ static void fillpattern (int type, unsigned char *r, size_t size) { size_t i; unsigned int bits = type & 0xfff; bits |= bits << 12; r[0] = (bits >> 4) & 255; r[1] = (bits >> 8) & 255; r[2] = bits & 255; for (i = 3; i < size / 2; i *= 2) <vul-start>memcpy (r + i, r, i);<vul-end> if (i < size) memcpy (r + i, r, size - i); /* Invert the first bit of every sector. */ if (type & 0x1000) for (i = 0; i < size; i += SECTOR_SIZE) r[i] ^= 0x80; }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> 3 ; i <= <vul-end> size / 2"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> *= 2 ) memcpy <vul-end> ( r +\n"
 },
 {
  "id": 4,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 /* -n K/N: Extract Kth of N chunks. */ static void bytes_chunk_extract (uintmax_t k, uintmax_t n, char *buf, size_t bufsize, size_t initial_read, off_t file_size) { off_t start; off_t end; assert (k && n && k <= n && n <= file_size); start = (k - 1) * (file_size / n); end = (k == n) ? file_size : k * (file_size / n); if (initial_read != SIZE_MAX || start < initial_read) { <vul-start>memmove (buf, buf + start, initial_read - start);<vul-end> initial_read -= start; } else { if (lseek (STDIN_FILENO, start, SEEK_CUR) < 0) die (EXIT_FAILURE, errno, \"%s\", quotef (infile)); initial_read = SIZE_MAX; } while (start < end) { size_t n_read; if (initial_read != SIZE_MAX) { n_read = initial_read; initial_read = SIZE_MAX; } else { n_read = safe_read (STDIN_FILENO, buf, bufsize); if (n_read == SAFE_READ_ERROR) die (EXIT_FAILURE, errno, \"%s\", quotef (infile)); } if (n_read == 0) break; /* eof. */ n_read = MIN (n_read, end - start); if (full_write (STDOUT_FILENO, buf, n_read) != n_read && ! ignorable (errno)) die (EXIT_FAILURE, errno, \"%s\", quotef (\"-\")); start += n_read; } }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> initial_read != SIZE_MAX <vul-end> || start <"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> initial_read ) { if ( initial_read < start ) initial_read = 0 ;\n"
 },
 {
  "id": 5,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 /* Set parameters related to formatting. */ static void init_parameters (int number_of_files) { int chars_used_by_number = 0; lines_per_body = lines_per_page - lines_per_header - lines_per_footer; if (lines_per_body <= 0) { extremities = false; keep_FF = true; } if (extremities == false) lines_per_body = lines_per_page; if (double_space) lines_per_body = lines_per_body / 2; /* If input is stdin, cannot print parallel files. BSD dumps core on this. */ if (number_of_files == 0) parallel_files = false; if (parallel_files) columns = number_of_files; /* One file, multi columns down: -b option is set to get a consistent formulation with \"FF set by hand\" in input files. */ if (storing_columns) balance_columns = true; /* Tabification is assumed for multiple columns. */ if (columns > 1) { if (!use_col_separator) { /* Use default separator */ if (join_lines) col_sep_string = line_separator; else col_sep_string = column_separator; col_sep_length = 1; use_col_separator = true; } /* It's rather pointless to define a TAB separator with column alignment */ <vul-start>else if (!join_lines && *col_sep_string == '\\t')<vul-end> col_sep_string = column_separator; truncate_lines = true; tabify_output = true; } else storing_columns = false; /* -J dominates -w in any case */ if (join_lines) truncate_lines = false; if (numbered_lines) { int chars_per_default_tab = 8; line_count = start_line_num; /* To allow input tab-expansion (-e sensitive) use: if",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> == '\\t' && col_sep_length == 1 <vul-end> col_sep_string = column_separator"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start>! join_lines && ( <vul-start> col_sep_string == '\\t' ) || ( join_lines && * col_sep_string == '\\\\t' )\n"
 },
 {
  "id": 6,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in) { jpc_siz_t *siz = &ms->parms.siz; unsigned int i; uint_fast8_t tmp; /* Eliminate compiler warning about unused variables. */ cstate = 0; if (jpc_getuint16(in, &siz->caps) || jpc_getuint32(in, &siz->width) || jpc_getuint32(in, &siz->height) || jpc_getuint32(in, &siz->xoff) || jpc_getuint32(in, &siz->yoff) || jpc_getuint32(in, &siz->tilewidth) || jpc_getuint32(in, &siz->tileheight) || jpc_getuint32(in, &siz->tilexoff) || jpc_getuint32(in, &siz->tileyoff) || jpc_getuint16(in, &siz->numcomps)) { return -1; } if (!siz->width || !siz->height || !siz->tilewidth || !siz->tileheight || !siz->numcomps) { return -1; } if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) { return -1; } for (i = 0; i < siz->numcomps; ++i) { if (jpc_getuint8(in, &tmp) || jpc_getuint8(in, &siz->comps[i].hsamp) || jpc_getuint8(in, &siz->comps[i].vsamp)) { jas_free(siz->comps); return -1; } <vul-start>siz->comps[i].sgnd = (tmp >> 7) & 1;<vul-end> siz->comps[i].prec = (tmp & 0x7f) + 1; } if (jas_stream_eof(in)) { jas_free(siz->comps); return -1; } return 0; }",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> 1 ; } if ((siz->comps[i].hsamp == 0) || (siz->comps[i].hsamp > 255) || (siz->comps[i].vsamp == 0) || (siz->comps[i].vsamp > 255)) return -1;"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> - 1 ; if ( siz -> comps [ i ]. hsamp == 0 || siz -> comps [ i ]. hsamp > 255 ) { jas_eprintf ( \"invalid XRsiz value %d\\\\n\", siz -> comps [ i ]. hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ]. vsamp == 0 || siz -> comps [ i ]. vsamp > 255 ) { jas_eprintf ( \"invalid YRsiz value %d\\\\n\", siz -> comps [ i ]. vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; }\n"
 },
 {
  "id": 7,
  "question": "CWE-190 Code Input Vulnerable Code Is: CWE-190 static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms) { jpc_siz_t *siz = &ms->parms.siz; int compno; int tileno; jpc_dec_tile_t *tile; jpc_dec_tcomp_t *tcomp; int htileno; int vtileno; jpc_dec_cmpt_t *cmpt; dec->xstart = siz->xoff; dec->ystart = siz->yoff; dec->xend = siz->width; dec->yend = siz->height; dec->tilewidth = siz->tilewidth; dec->tileheight = siz->tileheight; dec->tilexoff = siz->tilexoff; dec->tileyoff = siz->tileyoff; dec->numcomps = siz->numcomps; if (!(dec->cp = jpc_dec_cp_create(dec->numcomps))) { return -1; } if (!(dec->cmpts = jas_alloc2(dec->numcomps, sizeof(jpc_dec_cmpt_t)))) { return -1; } for (compno = 0, cmpt = dec->cmpts; compno < dec->numcomps; ++compno, ++cmpt) { cmpt->prec = siz->comps[compno].prec; cmpt->sgnd = siz->comps[compno].sgnd; cmpt->hstep = siz->comps[compno].hsamp; cmpt->vstep = siz->comps[compno].vsamp; cmpt->width = JPC_CEILDIV(dec->xend, cmpt->hstep) - JPC_CEILDIV(dec->xstart, cmpt->hstep); cmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) - JPC_CEILDIV(dec->ystart, cmpt->vstep); cmpt->hsubstep = 0; cmpt->vsubstep = 0; } dec->image = 0; <vul-start>dec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);<vul-end> dec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight); dec->numtiles = dec->numhtiles * dec->numvtiles; JAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\", dec->numtiles, dec->numhtiles, dec->numvtiles)); if (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) { return -1; } for (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno, ++tile) { htileno = tileno % dec->numhtiles; vtileno = tileno / dec->numhtiles; tile->realmode = 0; tile->state = JPC_TILE_INIT; tile->xstart = JAS_MAX(dec->tilexoff + htileno * dec->tilewidth, dec->xstart); tile->ystart = JAS_MAX(dec->tileyoff + vtileno * dec->tileheight, dec->ystart); tile->xend = JAS_MIN(dec->tilexoff + (htileno + 1)",
  "golden_answers": [
   "CWE-190 Fixed Code Lines are: <vul-start> 0 ; } if (dec->yend <= dec->tileyoff) return -1;"
  ],
  "generated_answer": "CWE-190 Fixed Code Lines are: <vul-start> = 0 ; int min_size = JAS_MIN ( JAS_CEILDIV ( dec -> xend - JPC_CEILDIV (dec -> xstart ) ), JAS_MAX ( JAS_CEILDIV ( dec -> yend - JPC_CEILDIV (dec -> ystart ) ) ) ; dec -> min_size = min_size ;\n"
 },
 {
  "id": 8,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 LOCAL(boolean) get_sos (j_decompress_ptr cinfo) /* Process a SOS marker */ { INT32 length; int i, ci, n, c, cc; jpeg_component_info * compptr; INPUT_VARS(cinfo); if (! cinfo->marker->saw_SOF) ERREXIT(cinfo, JERR_SOS_NO_SOF); INPUT_2BYTES(cinfo, length, return FALSE); INPUT_BYTE(cinfo, n, return FALSE); /* Number of components */ TRACEMS1(cinfo, 1, JTRC_SOS, n); if (length != (n * 2 + 6) || n < 1 || n > MAX_COMPS_IN_SCAN) ERREXIT(cinfo, JERR_BAD_LENGTH); cinfo->comps_in_scan = n; /* Collect the component-spec parameters */ for (i = 0; i < cinfo->num_components; i++) <vul-start>cinfo->cur_comp_info[i] = NULL;<vul-end> for (i = 0; i < n; i++) { INPUT_BYTE(cinfo, cc, return FALSE); INPUT_BYTE(cinfo, c, return FALSE); for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++, compptr++) { if (cc == compptr->component_id && !cinfo->cur_comp_info[ci]) goto id_found; } ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc); id_found: cinfo->cur_comp_info[i] = compptr; compptr->dc_tbl_no = (c >> 4) & 15; compptr->ac_tbl_no = (c ) & 15; TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc, compptr->dc_tbl_no, compptr->ac_tbl_no); } /* Collect the additional scan parameters Ss, Se, Ah/Al. */ INPUT_BYTE(cinfo, c, return FALSE); cinfo->Ss = c; INPUT_BYTE(cinfo, c, return FALSE); cinfo->Se = c; INPUT_BYTE(cinfo, c, return FALSE); cinfo->Ah = (c >> 4) & 15; cinfo->Al = (c ) & 15; TRACEMS4(cinfo, 1, JTRC_SOS_PARAMS, cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al); /* Prepare to scan data & restart markers */ cinfo->marker->next_restart_num = 0;",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> cinfo -> num_components && i < MAX_COMPS_IN_SCAN"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> i++) cinfo->cur_comp_info[i] = NULL ; if (! cinfo -> cur_comp_info ) return FALSE ; for ( i = 0 ; i < n ; i ++ ) { INPUT_BYTE ( cinfo, * ( cinfo -> comp_info + i ) ) ; if (! cinfo -> cur_comp_info [ i ] ) return FALSE ; } <vul-end> INPUT_SYNC (cinfo\n"
 },
 {
  "id": 9,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 METHODDEF(void) quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows) /* General case, with ordered dithering */ { my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize; register JSAMPROW input_ptr; register JSAMPROW output_ptr; JSAMPROW colorindex_ci; int *dither; /* points to active row of dither matrix */ int row_index, col_index; /* current indexes into dither matrix */ int nc = cinfo->out_color_components; int ci; int row; JDIMENSION col; JDIMENSION width = cinfo->output_width; for (row = 0; row < num_rows; row++) { /* Initialize output values to 0 so can process components separately */ <vul-start>jzero_far((void *) output_buf[row], (size_t) (width * sizeof(JSAMPLE)));<vul-end> row_index = cquantize->row_index; for (ci = 0; ci < nc; ci++) { input_ptr = input_buf[row] + ci; output_ptr = output_buf[row]; colorindex_ci = cquantize->colorindex[ci]; dither = cquantize->odither[ci][row_index]; col_index = 0; for (col = width; col > 0; col--) { /* Form pixel value + dither, range-limit to 0..MAXJSAMPLE, * select output value, accumulate into output code for this pixel. * Range-limiting need not be done explicitly, as we have extended * the colorindex table to produce the right answers for out-of-range * inputs. The maximum dither is +- MAXJSAMPLE; this sets the * required amount of padding. */ *output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]]; input_ptr += nc; output_ptr++; col_index = (col_index + 1) & ODITHER_MASK; } } /* Advance",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> -> output_width ; if ((output_buf == 0) && (num_rows > 0)) ERREXIT(cinfo, JERR_BAD_STATE);"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start> components separately */ jzero_far ( void * ) output_buf [row ], <vul-end> (size_t ) (\n"
 },
 {
  "id": 10,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 /* * Read one row of pixels. * The image has been read into the whole_image array, but is otherwise * unprocessed. We must read it out in top-to-bottom row order, and if * it is an 8-bit image, we must expand colormapped pixels to 24bit format. */ METHODDEF(JDIMENSION) get_8bit_row (j_compress_ptr cinfo, cjpeg_source_ptr sinfo) /* This version is for reading 8-bit colormap indexes */ { bmp_source_ptr source = (bmp_source_ptr) sinfo; register JSAMPARRAY colormap = source->colormap; JSAMPARRAY image_ptr; register int t; register JSAMPROW inptr, outptr; register JDIMENSION col; /* Fetch next row from virtual array */ source->source_row--; image_ptr = (*cinfo->mem->access_virt_sarray) ((j_common_ptr) cinfo, source->whole_image, source->source_row, (JDIMENSION) 1, FALSE); /* Expand the colormap indexes to real data */ inptr = image_ptr[0]; outptr = source->pub.buffer[0]; for (col = cinfo->image_width; col > 0; col--) { t = GETJSAMPLE(*inptr++); <vul-start>*outptr++ = colormap[0][t];<vul-end> /* can omit GETJSAMPLE() safely */ *outptr++ = colormap[1][t]; *outptr++ = colormap[2][t]; } return 1; }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ++ ) ; if (t >= source->cmap_length) exit(1);"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> inptr++ ; * ( outptr ++ ) = colormap [ 0 ] [ t ] ; * ( outptr ++ ) = colormap [ 1 ] [ t ] ; * ( outptr ++ ) = colormap [ 2 ] [ t ] <vul-end> ; } return\n"
 },
 {
  "id": 11,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 /* * The module selection routine for BMP format output. */ GLOBAL(djpeg_dest_ptr) jinit_write_bmp(j_decompress_ptr cinfo, boolean is_os2, boolean use_inversion_array) { bmp_dest_ptr dest; JDIMENSION row_width; /* Create module interface object, fill in method pointers */ dest = (bmp_dest_ptr) (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE, sizeof(bmp_dest_struct)); dest->pub.start_output = start_output_bmp; dest->pub.finish_output = finish_output_bmp; dest->pub.calc_buffer_dimensions = NULL; dest->is_os2 = is_os2; if (cinfo->out_color_space == JCS_GRAYSCALE) { dest->pub.put_pixel_rows = put_gray_rows; } else if (IsExtRGB(cinfo->out_color_space)) { if (cinfo->quantize_colors) dest->pub.put_pixel_rows = put_gray_rows; else dest->pub.put_pixel_rows = put_pixel_rows; } else if (cinfo->out_color_space == JCS_RGB565 || cinfo->out_color_space == JCS_CMYK) { <vul-start>dest->pub.put_pixel_rows = put_pixel_rows;<vul-end> } else { ERREXIT(cinfo, JERR_BMP_COLORSPACE); } /* Calculate output image dimensions so we can allocate space */ jpeg_calc_output_dimensions(cinfo); /* Determine width of rows in the BMP file (padded to 4-byte boundary). */ if (cinfo->out_color_space == JCS_RGB565) { row_width = cinfo->output_width * 2; dest->row_width = dest->data_width = cinfo->output_width * 3; while ((row_width & 3) != 0) row_width++; } else if (!cinfo->quantize_colors && (IsExtRGB(cinfo->out_color_space) || cinfo->out_color_space == JCS_CMYK)) { row_width = cinfo->output_width * cinfo->output_components; dest->row_width = dest->data_width = cinfo->output_width * 3; } else { row_width = cinfo->output_width * cinfo->output_components; dest->row_width = dest->data_width = row_width; } while ((dest->row_width & 3) != 0) dest->row_width++; dest->pad_bytes = (int)(dest->row_width - dest->data_width); if (use_inversion_array) { /* Allocate space for inversion array, prepare for write pass */ dest->whole_image =",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start>else if ( ( <vul-start> out_color_space == JCS_CMYK ) && cinfo->quantize_colors == 0"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> JCS_CMYK ) { if ( cinfo -> quantize_colors ) dest -> pub. put_pixel_rows = put_gray_rows ; else dest -> pub. put_pixel_rows = <vul-end> put_pixel_rows ; }\n"
 },
 {
  "id": 12,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static int OJPEGDecodeRaw(TIFF* tif, uint8* buf, tmsize_t cc) { static const char module[]=\"OJPEGDecodeRaw\"; OJPEGState* sp=(OJPEGState*)tif->tif_data; uint8* m; tmsize_t n; uint8* oy; uint8* ocb; uint8* ocr; uint8* p; uint32 q; uint8* r; uint8 sx,sy; <vul-start>if (cc%sp->bytes_per_line!=0)<vul-end> { TIFFErrorExt(tif->tif_clientdata,module,\"Fractional scanline not read\"); return(0); } assert(cc>0); m=buf; n=cc; do { if (sp->subsampling_convert_state==0) { if (jpeg_read_raw_data_encap(sp,&(sp->libjpeg_jpeg_decompress_struct),sp->subsampling_convert_ycbcrimage,sp->subsampling_ver*8)==0) return(0); } oy=sp->subsampling_convert_ybuf+sp->subsampling_convert_state*sp->subsampling_ver*sp->subsampling_convert_ylinelen; ocb=sp->subsampling_convert_cbbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen; ocr=sp->subsampling_convert_crbuf+sp->subsampling_convert_state*sp->subsampling_convert_clinelen; p=m; for (q=0; q<sp->subsampling_convert_clinelenout; q++) { r=oy; for (sy=0; sy<sp->subsampling_ver; sy++) { for (sx=0; sx<sp->subsampling_hor; sx++) *p++=*r++; r+=sp->subsampling_convert_ylinelen-sp->subsampling_hor; } oy+=sp->subsampling_hor; *p++=*ocb++; *p++=*ocr++; } sp->subsampling_convert_state++; if (sp->subsampling_convert_state==sp->subsampling_convert_clines) sp->subsampling_convert_state=0; m+=sp->bytes_per_line; n-=sp->bytes_per_line; } while(n>0); return(1); }",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> , sy ; if (sp->bytes_per_line == 0) return -1;"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> uint8 sx, sy ; if ( cc == 0 ) { TIFFErrorExt (tif ->tif_clientdata, \"Fractional scanline not read\" ) ; return 0 ; } <vul-end> assert ( cc>0\n"
 },
 {
  "id": 13,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 void PSDataColorContig(FILE* fd, TIFF* tif, uint32 w, uint32 h, int nc) { uint32 row; int breaklen = MAXLINE, es = samplesperpixel - nc; tsize_t cc; unsigned char *tf_buf; unsigned char *cp, c; (void) w; tf_buf = (unsigned char *) _TIFFmalloc(tf_bytesperrow); if (tf_buf == NULL) { TIFFError(filename, \"No space for scanline buffer\"); return; } for (row = 0; row < h; row++) { if (TIFFReadScanline(tif, tf_buf, row, 0) < 0) break; cp = tf_buf; /* * for 16 bits, the two bytes must be most significant * byte first */ if (bitspersample == 16 && !HOST_BIGENDIAN) { PS_FlipBytes(cp, tf_bytesperrow); } if (alpha) { int adjust; cc = 0; for (; cc < tf_bytesperrow; cc += samplesperpixel) { DOBREAK(breaklen, nc, fd); /* * For images with alpha, matte against * a white background; i.e. * Cback * (1 - Aimage) * where Cback = 1. */ adjust = 255 - cp[nc]; switch (nc) { case 4: c = *cp++ + adjust; PUTHEX(c,fd); case 3: c = *cp++ + adjust; PUTHEX(c,fd); case 2: c = *cp++ + adjust; PUTHEX(c,fd); case 1: c = *cp++ + adjust; PUTHEX(c,fd); } <vul-start>cp += es;<vul-start> } } else { cc = 0; for (; cc < tf_bytesperrow; cc += samplesperpixel) { DOBREAK(breaklen, nc, fd); switch (nc)",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> , c ; if (es <= 0) return;"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> += es ; es -= es ;\n"
 },
 {
  "id": 14,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 /* * Install the specified image. The * image is resized to fit the display page using * a box filter. The resultant pixels are mapped * with a user-selectable contrast curve. */ static void setImage1(const uint8* br, uint32 rw, uint32 rh) { int step = rh; int limit = tnh; int err = 0; int bpr = TIFFhowmany8(rw); int sy = 0; uint8* row = thumbnail; uint32 dy; for (dy = 0; dy < tnh; dy++) { const uint8* rows[256]; uint32 nrows = 1; fprintf(stderr, \"bpr=%d, sy=%d, bpr*sy=%d\\n\", bpr, sy, bpr*sy); rows[0] = br + bpr*sy; err += step; while (err >= limit) { err -= limit; sy++; if (err >= limit) <vul-start>rows[nrows++] = br + bpr*sy;<vul-end> } setrow(row, nrows, rows); row += tnw; } }",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> err >= limit && nrows < 256"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> >= limit ) { fprintf ( stderr, \"bpr=%d sy=%d bpr*sy=%d\\n\", bpr, sy, bpr *sy ) ; <vul-start> += tnw ; }\n"
 },
 {
  "id": 15,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 /* * readextension - * Read a GIF extension block (and do nothing with it). * */ int readextension(void) { int count; char buf[255]; int status = 1; (void) getc(infile); while ((count = getc(infile)) && count <= 255) <vul-start>if (fread(buf, 1, count, infile) != (size_t) count) <vul-end>{ fprintf(stderr, \"short read from file %s (%s)\\n\", filename, strerror(errno)); status = 0; break; } return status; }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> count <= 255 && count >= 0"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> ) if ( feof ( infile ) ) { fprintf ( stderr, \"could not read from file %s (%s): %m\\\\n\", filename, strerror ( errno ) ) ; status = 0 ; break ; } if (\n"
 },
 {
  "id": 16,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static int cvtRaster(TIFF* tif, uint32* raster, uint32 width, uint32 height) { uint32 y; tstrip_t strip = 0; tsize_t cc, acc; unsigned char* buf; <vul-start>uint32 rwidth = roundup(width, horizSubSampling);<vul-end> uint32 rheight = roundup(height, vertSubSampling); uint32 nrows = (rowsperstrip > rheight ? rheight : rowsperstrip); uint32 rnrows = roundup(nrows,vertSubSampling); cc = rnrows*rwidth + 2*((rnrows*rwidth) / (horizSubSampling*vertSubSampling)); buf = (unsigned char*)_TIFFmalloc(cc); // FIXME unchecked malloc for (y = height; (int32) y > 0; y -= nrows) { uint32 nr = (y > nrows ? nrows : y); cvtStrip(buf, raster + (y-1)*width, nr, width); nr = roundup(nr, vertSubSampling); acc = nr*rwidth + 2*((nr*rwidth)/(horizSubSampling*vertSubSampling)); if (!TIFFWriteEncodedStrip(tif, strip++, buf, acc)) { _TIFFfree(buf); return (0); } } _TIFFfree(buf); return (1); }",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> * buf ; if (horizSubSampling == 0 || vertSubSampling == 0) usage(-1);"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> * buf ; uint64 rwidth = roundup ( width ) ; uint64 rheight = roundup ( height ) ;\n"
 },
 {
  "id": 17,
  "question": "CWE-787 Code Input Vulnerable Code Is: CWE-787 static int PixarLogDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s) { static const char module[] = \"PixarLogDecode\"; TIFFDirectory *td = &tif->tif_dir; PixarLogState* sp = DecoderState(tif); tmsize_t i; tmsize_t nsamples; int llen; uint16 *up; switch (sp->user_datafmt) { case PIXARLOGDATAFMT_FLOAT: nsamples = occ / sizeof(float); /* XXX float == 32 bits */ break; case PIXARLOGDATAFMT_16BIT: case PIXARLOGDATAFMT_12BITPICIO: case PIXARLOGDATAFMT_11BITLOG: nsamples = occ / sizeof(uint16); /* XXX uint16 == 16 bits */ break; case PIXARLOGDATAFMT_8BIT: case PIXARLOGDATAFMT_8BITABGR: nsamples = occ; break; default: TIFFErrorExt(tif->tif_clientdata, module, \"%d bit input not supported in PixarLog\", td->td_bitspersample); return 0; } llen = sp->stride * td->td_imagewidth; (void) s; assert(sp != NULL); sp->stream.next_out = (unsigned char *) sp->tbuf; assert(sizeof(sp->stream.avail_out)==4); /* if this assert gets raised, we need to simplify this code to reflect a ZLib that is likely updated to deal with 8byte memory sizes, though this code will respond appropriately even before we simplify it */ sp->stream.avail_out = (uInt) (nsamples * sizeof(uint16)); if (sp->stream.avail_out != nsamples * sizeof(uint16)) { TIFFErrorExt(tif->tif_clientdata, module, \"ZLib cannot deal with buffers this size\"); return (0); } do { int state = inflate(&sp->stream, Z_PARTIAL_FLUSH); if (state == Z_STREAM_END) { break; /* XXX */ } if (state == Z_DATA_ERROR) { TIFFErrorExt(tif->tif_clientdata, module, \"Decoding error at scanline %lu, %s\", (unsigned long) tif->tif_row, sp->stream.msg ? sp->stream.msg :",
  "golden_answers": [
   "CWE-787 Fixed Code Lines are: <vul-start> ) ; } if (sp->stream.avail_out > sp->tbuf_size) return 0;"
  ],
  "generated_answer": "CWE-787 Fixed Code Lines are: <vul-start> ; } } if ( sp -> stream. avail_in < 0 ) { TIFFErrorExt (tif ->tif_clientdata, \"Not enough data at scanline %lu (short \" TIFF_UINT64_FORMAT \" bytes)\", ( unsigned long ) sp -> stream. avail_in ) ; return 0 ; }\n"
 },
 {
  "id": 18,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, uint32 imagelength, uint32 imagewidth, uint32 tw, uint32 tl, uint16 spp, uint16 bps) { int i, status = 1, sample; int shift_width, bytes_per_pixel; uint16 bytes_per_sample; uint32 row, col; /* Current row and col of image */ uint32 nrow, ncol; /* Number of rows and cols in current tile */ uint32 row_offset, col_offset; /* Output buffer offsets */ tsize_t tbytes = 0, tilesize = TIFFTileSize(in); tsample_t s; uint8* bufp = (uint8*)obuf; unsigned char *srcbuffs[MAX_SAMPLES]; unsigned char *tbuff = NULL; bytes_per_sample = (bps + 7) / 8; for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++) { srcbuffs[sample] = NULL; tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8); if (!tbuff) { TIFFError (\"readSeparateTilesIntoBuffer\", \"Unable to allocate tile read buffer for sample %d\", sample); for (i = 0; i < sample; i++) _TIFFfree (srcbuffs[i]); return 0; } srcbuffs[sample] = tbuff; } /* Each tile contains only the data for a single plane * arranged in scanlines of tw * bytes_per_sample bytes. */ for (row = 0; row < imagelength; row += tl) { nrow = (row + tl > imagelength) ? imagelength - row : tl; for (col = 0; col < imagewidth; col += tw) { for (s = 0; s < spp;",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> s < spp && s < MAX_SAMPLES"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> srcbuffs [ s + 1\n"
 },
 {
  "id": 19,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 /* * Compute how many strips are in an image. */ uint32 TIFFNumberOfStrips(TIFF* tif) { TIFFDirectory *td = &tif->tif_dir; uint32 nstrips; nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 : TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip)); if (td->td_planarconfig == PLANARCONFIG_SEPARATE) <vul-start>nstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel, \"TIFFNumberOfStrips\");<vul-end> return (nstrips); }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> uint32 nstrips ; if (td->td_nstrip != 0) return td->td_nstrips;"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> ) nstrips = _TIFF_MULT_32 <vul-end> (tif nstrips ( <vul-start> ( uint32 ) TIFF_SAMPLE_PERPIXELS <vul-end>, \"TIFFNumberOfStrips\");\" ;\n"
 },
 {
  "id": 20,
  "question": "CWE-189 Code Input Vulnerable Code Is: CWE-189 /* * This function reads the raster image data from the input TIFF for an image * tile and writes the data to the output PDF XObject image dictionary stream * for the tile. It returns the amount written or zero on error. */ tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){ uint16 edge=0; tsize_t written=0; unsigned char* buffer=NULL; tsize_t bufferoffset=0; unsigned char* samplebuffer=NULL; tsize_t samplebufferoffset=0; tsize_t read=0; uint16 i=0; ttile_t tilecount=0; /* tsize_t tilesize=0; */ ttile_t septilecount=0; tsize_t septilesize=0; #ifdef JPEG_SUPPORT unsigned char* jpt; float* xfloatp; uint32 xuint32=0; #endif /* Fail if prior error (in particular, can't trust tiff_datasize) */ if (t2p->t2p_error != T2P_ERR_OK) return(0); edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile); edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile); if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0) #if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT) || (t2p->pdf_compression == T2P_COMPRESS_JPEG) #endif ) ){ #ifdef CCITT_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_G4){ buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE, \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\", (unsigned long) t2p->tiff_datasize, TIFFFileName(input)); t2p->t2p_error = T2P_ERR_ERROR; return(0); } TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize); if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){ TIFFReverseBits(buffer, t2p->tiff_datasize); } t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize); _TIFFfree(buffer); return(t2p->tiff_datasize); } #endif #ifdef ZIP_SUPPORT if(t2p->pdf_compression == T2P_COMPRESS_ZIP){ buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize); if(buffer==NULL){ TIFFError(TIFF2PDF_MODULE, \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile, %s\", (unsigned long) t2p->tiff_datasize, TIFFFileName(input)); t2p->t2p_error =",
  "golden_answers": [
   "CWE-189 Fixed Code Lines are: <vul-start>if ( count > <vul-end> { int retTIFFReadRawTile"
  ],
  "generated_answer": "CWE-189 Fixed Code Lines are: <vul-start> } if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE \"Can't allocate %lu bytes of memory \" \"for t2p_readwrite_pdf_image_tile %s\", ( unsigned long ) t2p -> tiff_datasize, TIFFFileName ( input ) ) ; _TIFFfree (buffer ) ; return ( 0 ) ; } if (\n"
 },
 {
  "id": 21,
  "question": "CWE-369 Code Input Vulnerable Code Is: CWE-369 static int JPEGSetupEncode(TIFF* tif) { JPEGState* sp = JState(tif); TIFFDirectory *td = &tif->tif_dir; static const char module[] = \"JPEGSetupEncode\"; #if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG) if( tif->tif_dir.td_bitspersample == 12 ) return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 ); #endif JPEGInitializeLibJPEG( tif, FALSE ); assert(sp != NULL); assert(!sp->cinfo.comm.is_decompressor); sp->photometric = td->td_photometric; /* * Initialize all JPEG parameters to default values. * Note that jpeg_set_defaults needs legal values for * in_color_space and input_components. */ if (td->td_planarconfig == PLANARCONFIG_CONTIG) { sp->cinfo.c.input_components = td->td_samplesperpixel; if (sp->photometric == PHOTOMETRIC_YCBCR) { if (sp->jpegcolormode == JPEGCOLORMODE_RGB) { sp->cinfo.c.in_color_space = JCS_RGB; } else { sp->cinfo.c.in_color_space = JCS_YCbCr; } } else { if ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1) sp->cinfo.c.in_color_space = JCS_GRAYSCALE; else if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3) sp->cinfo.c.in_color_space = JCS_RGB; else if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4) sp->cinfo.c.in_color_space = JCS_CMYK; else sp->cinfo.c.in_color_space = JCS_UNKNOWN; } } else { sp->cinfo.c.input_components = 1; sp->cinfo.c.in_color_space = JCS_UNKNOWN; } if (!TIFFjpeg_set_defaults(sp)) return (0); /* Set per-file parameters */ switch (sp->photometric) { case PHOTOMETRIC_YCBCR: sp->h_sampling = td->td_ycbcrsubsampling[0]; sp->v_sampling = td->td_ycbcrsubsampling[1]; /* * A ReferenceBlackWhite field *must* be present since the * default value is inappropriate for YCbCr. Fill in the * proper value if application didn't set it. */ { float *ref; if (!TIFFGetField(tif, TIFFTAG_REFERENCEBLACKWHITE, &ref))",
  "golden_answers": [
   "CWE-369 Fixed Code Lines are: <vul-start> ) ) { if (sp->v_sampling == 0 || sp->h_sampling == 0) return 0;"
  ],
  "generated_answer": "CWE-369 Fixed Code Lines are: <vul-start> isTiled (tif ) && td -> td_samplesperpixel == 0\n"
 },
 {
  "id": 22,
  "question": "CWE-20 Code Input Vulnerable Code Is: CWE-20 static int JPEGSetupEncode(TIFF* tif) { JPEGState* sp = JState(tif); TIFFDirectory *td = &tif->tif_dir; static const char module[] = \"JPEGSetupEncode\"; #if defined(JPEG_DUAL_MODE_8_12) && !defined(TIFFInitJPEG) if( tif->tif_dir.td_bitspersample == 12 ) return TIFFReInitJPEG_12( tif, COMPRESSION_JPEG, 1 ); #endif JPEGInitializeLibJPEG( tif, FALSE ); assert(sp != NULL); assert(!sp->cinfo.comm.is_decompressor); sp->photometric = td->td_photometric; /* * Initialize all JPEG parameters to default values. * Note that jpeg_set_defaults needs legal values for * in_color_space and input_components. */ if (td->td_planarconfig == PLANARCONFIG_CONTIG) { sp->cinfo.c.input_components = td->td_samplesperpixel; if (sp->photometric == PHOTOMETRIC_YCBCR) { if (sp->jpegcolormode == JPEGCOLORMODE_RGB) { sp->cinfo.c.in_color_space = JCS_RGB; } else { sp->cinfo.c.in_color_space = JCS_YCbCr; } } else { if ((td->td_photometric == PHOTOMETRIC_MINISWHITE || td->td_photometric == PHOTOMETRIC_MINISBLACK) && td->td_samplesperpixel == 1) sp->cinfo.c.in_color_space = JCS_GRAYSCALE; else if (td->td_photometric == PHOTOMETRIC_RGB && td->td_samplesperpixel == 3) sp->cinfo.c.in_color_space = JCS_RGB; else if (td->td_photometric == PHOTOMETRIC_SEPARATED && td->td_samplesperpixel == 4) sp->cinfo.c.in_color_space = JCS_CMYK; else sp->cinfo.c.in_color_space = JCS_UNKNOWN; } } else { sp->cinfo.c.input_components = 1; sp->cinfo.c.in_color_space = JCS_UNKNOWN; } if (!TIFFjpeg_set_defaults(sp)) return (0); /* Set per-file parameters */ switch (sp->photometric) { case PHOTOMETRIC_YCBCR: sp->h_sampling = td->td_ycbcrsubsampling[0]; sp->v_sampling = td->td_ycbcrsubsampling[1]; if( sp->h_sampling == 0 || sp->v_sampling == 0 ) { TIFFErrorExt(tif->tif_clientdata, module, \"Invalig horizontal/vertical sampling value\"); return (0); } /* * A ReferenceBlackWhite field *must* be present since the * default value is inappropriate for YCbCr.",
  "golden_answers": [
   "CWE-20 Fixed Code Lines are: <vul-start> ) ; } if (td->td_bitspersample > 16) return 0;"
  ],
  "generated_answer": "CWE-20 Fixed Code Lines are: <vul-start> = ( float ) ( ( top - 1L ) >> 1 ) <vul-end> ; refbw [\n"
 },
 {
  "id": 23,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 /** * xmlParseAttValueComplex: * @ctxt: an XML parser context * @len: the resulting attribute len * @normalize: wether to apply the inner normalization * * parse a value for an attribute, this is the fallback function * of xmlParseAttValue() when the attribute parsing requires handling * of non-ASCII characters, or normalization compaction. * * Returns the AttValue parsed or NULL. The value has to be freed by the caller. */ static xmlChar * xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) { xmlChar limit = 0; xmlChar *buf = NULL; xmlChar *rep = NULL; size_t len = 0; size_t buf_size = 0; int c, l, in_space = 0; xmlChar *current = NULL; xmlEntityPtr ent; if (NXT(0) == '\"') { ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE; limit = '\"'; NEXT; } else if (NXT(0) == '\\'') { limit = '\\''; ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE; NEXT; } else { xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL); return(NULL); } /* * allocate a translation buffer. */ buf_size = XML_PARSER_BUFFER_SIZE; buf = (xmlChar *) xmlMallocAtomic(buf_size); if (buf == NULL) goto mem_error; /* * OK loop until we reach one of the ending char or a size limit. */ c = CUR_CHAR(l); while (((NXT(0) != limit) && /* checked */ (IS_CHAR(c)) && (c != '<')) && (ctxt->instate != XML_PARSER_EOF)) { /* * Impose a",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> { while ( len > 0 &&"
  ],
  "generated_answer": "CWE-119 Fixed Code Lines are: <vul-start> { while ( ( len > 0 ) && ( <vul-start> == 0x20 ) )\n"
 },
 {
  "id": 24,
  "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 /** * xmlStrncat: * @cur: the original xmlChar * array * @add: the xmlChar * array added * @len: the length of @add * * a strncat for array of xmlChar's, it will extend @cur with the len * first bytes of @add. Note that if @len < 0 then this is an API error * and NULL will be returned. * * Returns a new xmlChar *, the original @cur is reallocated if needed * and should not be freed */ xmlChar * xmlStrncat(xmlChar *cur, const xmlChar *add, int len) { int size; xmlChar *ret; if ((add == NULL) || (len == 0)) return(cur); if (len < 0) return(NULL); if (cur == NULL) return(xmlStrndup(add, len)); size = xmlStrlen(cur); <vul-start>ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));<vul-end> if (ret == NULL) { xmlErrMemory(NULL, NULL); return(cur); } memcpy(&ret[size], add, len * sizeof(xmlChar)); ret[size + len] = 0; return(ret); }",
  "golden_answers": [
   "CWE-119 Fixed Code Lines are: <vul-start> cur ) ; if (size < 0) return NULL;"
  ],
  "generated_answer": "CWE-120 Fixed Code Lines are: <vul-start> ( xmlChar * ) xmlRealloc ( cur, <vul-end> size + len\n"
 },
 {
  "id": 25,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 /** * xmlParseEndTag2: * @ctxt: an XML parser context * @line: line of the start tag * @nsNr: number of namespaces on the start tag * * parse an end of tag * * [42] ETag ::= '</' Name S? '>' * * With namespace * * [NS 9] ETag ::= '</' QName S? '>' */ static void xmlParseEndTag2(xmlParserCtxtPtr ctxt, const xmlChar *prefix, const xmlChar *URI, int line, int nsNr, int tlen) { const xmlChar *name; GROW; if ((RAW != '<') || (NXT(1) != '/')) { xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL); return; } SKIP(2); if ((tlen > 0) && (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) { if (ctxt->input->cur[tlen] == '>') { <vul-start>ctxt->input->cur += tlen + 1;<vul-end> ctxt->input->col += tlen + 1; goto done; } ctxt->input->cur += tlen; ctxt->input->col += tlen; name = (xmlChar*)1; } else { if (prefix == NULL) name = xmlParseNameAndCompare(ctxt, ctxt->name); else name = xmlParseQNameAndCompare(ctxt, ctxt->name, prefix); } /* * We should definitely be at the ending \"S? '>'\" part */ GROW; if (ctxt->instate == XML_PARSER_EOF) return; SKIP_BLANKS; if ((!IS_BYTE_CHAR(RAW)) || (RAW != '>')) { xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL); } else NEXT1; /* * [ WFC: Element Type Match ] * The Name in an element's end-tag must match the element type in the * start-tag. * */ if (name",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> > 0 ) && ((ctxt->input->end - ctxt->input->cur) >= tlen)"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> += tlen + 1 ; ctxt->input->col += tlen + 1 ; goto done ; } ctxt -> input -> cur += tlen ; ctxt -> input -> col += tlen ; done : <vul-end> if ( ctxt\n"
 },
 {
  "id": 26,
  "question": "CWE-125 Code Input Vulnerable Code Is: CWE-125 static const xmlChar * htmlParseNameComplex(xmlParserCtxtPtr ctxt) { int len = 0, l; int c; int count = 0; /* * Handler for more complex cases */ GROW; c = CUR_CHAR(l); if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */ (!IS_LETTER(c) && (c != '_') && (c != ':'))) { return(NULL); } while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */ ((IS_LETTER(c)) || (IS_DIGIT(c)) || (c == '.') || (c == '-') || (c == '_') || (c == ':') || (IS_COMBINING(c)) || (IS_EXTENDER(c)))) { if (count++ > 100) { count = 0; GROW; } len += l; NEXTL(l); c = CUR_CHAR(l); } <vul-start>return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));<vul-end> }",
  "golden_answers": [
   "CWE-125 Fixed Code Lines are: <vul-start> ) ; } if (ctxt->input->base > (ctxt->input->cur - len)) return NULL;"
  ],
  "generated_answer": "CWE-125 Fixed Code Lines are: <vul-start> } return ( ( ctxt -> input -> flags & XML_PARSE_NOENT ) == 0? ( xmlDictLookup ( ctxt -> dict, ctxt -> input -> cur - len, len ) ) : ( <vul-start> - len, ( ctxt -> input -> cur - len )\n"
 },
 {
  "id": 27,
  "question": "CWE-476 Code Input Vulnerable Code Is: CWE-476 /** * xmlDumpElementContent: * @buf: An XML buffer * @content: An element table * @glob: 1 if one must print the englobing parenthesis, 0 otherwise * * This will dump the content of the element table as an XML DTD definition */ static void xmlDumpElementContent(xmlBufferPtr buf, xmlElementContentPtr content, int glob) { if (content == NULL) return; if (glob) xmlBufferWriteChar(buf, \"(\"); switch (content->type) { case XML_ELEMENT_CONTENT_PCDATA: xmlBufferWriteChar(buf, \"#PCDATA\"); break; case XML_ELEMENT_CONTENT_ELEMENT: if (content->prefix != NULL) { xmlBufferWriteCHAR(buf, content->prefix); xmlBufferWriteChar(buf, \":\"); } xmlBufferWriteCHAR(buf, content->name); break; case XML_ELEMENT_CONTENT_SEQ: if ((content->c1->type == XML_ELEMENT_CONTENT_OR) || (content->c1->type == XML_ELEMENT_CONTENT_SEQ)) xmlDumpElementContent(buf, content->c1, 1); else xmlDumpElementContent(buf, content->c1, 0); xmlBufferWriteChar(buf, \" , \"); <vul-start>if ((content->c2->type == XML_ELEMENT_CONTENT_OR) || ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) && (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)))<vul-end> xmlDumpElementContent(buf, content->c2, 1); else xmlDumpElementContent(buf, content->c2, 0); break; case XML_ELEMENT_CONTENT_OR: if ((content->c1->type == XML_ELEMENT_CONTENT_OR) || (content->c1->type == XML_ELEMENT_CONTENT_SEQ)) xmlDumpElementContent(buf, content->c1, 1); else xmlDumpElementContent(buf, content->c1, 0); xmlBufferWriteChar(buf, \" | \"); if ((content->c2->type == XML_ELEMENT_CONTENT_SEQ) || ((content->c2->type == XML_ELEMENT_CONTENT_OR) && (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE))) xmlDumpElementContent(buf, content->c2, 1); else xmlDumpElementContent(buf, content->c2, 0); break; default: xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR, \"Internal: ELEMENT content corrupted invalid type\\n\", NULL); } if (glob) xmlBufferWriteChar(buf, \")\"); switch (content->ocur) { case XML_ELEMENT_CONTENT_ONCE: break; case XML_ELEMENT_CONTENT_OPT: xmlBufferWriteChar(buf, \"?\"); break; case XML_ELEMENT_CONTENT_MULT: xmlBufferWriteChar(buf, \"*\"); break; case XML_ELEMENT_CONTENT_PLUS: xmlBufferWriteChar(buf, \"+\"); break; } }",
  "golden_answers": [
   "CWE-476 Fixed Code Lines are: <vul-start> \" , \" ) ; if (content->c2 == NULL) break;"
  ],
  "generated_answer": "CWE-476 Fixed Code Lines are: <vul-start>, \"); if ( ((content->c2->type == XML_ELEMENT_CONTENT_OR) || (content->c2->type == XML_ELEMENT_CONTENT_SEQ) && (content->c2->ocur!= XML_ELEMENT_CONTENT_ONCE))) xmlDumpElementContent(buf); else xmlDumpElementContent(buf);\" ) ; if ( <vul-end> ( content -> <vul-start> == XML_ELEMENT_CONTENT_OR ) || (content->c2->type == XML_ELEMENT_CONTENT_SEQ ) && (content->c2->ocur!= XML_ELEMENT_CONTENT_ONCE))) xmlDumpElementContent(buf); else xmlDumpElementContent(buf); \" ) ; if ( <vul-end> ( content -> <vul-start> == XML_ELEMENT_CONTENT_OR ) || (content->c2->type == XML_ELEMENT_CONTENT_SEQ )\n"
 }
]