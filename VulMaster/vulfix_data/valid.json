[
    {
        "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static uint8_t excluded_channels ( bitfile * ld , drc_info * drc ) { uint8_t i , n = 0 ; uint8_t num_excl_chan = 7 ; for ( i = 0 ; i < 7 ; i ++ ) { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 103 , \"excluded_channels(): exclude_mask\" ) ) ; } n ++ ; while ( ( drc -> additional_excluded_chns [ n - 1 ] = faad_get1bit ( ld DEBUGVAR ( 1 , 104 , \"excluded_channels(): additional_excluded_chns\" ) ) ) == 1 ) { <vul-start> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <vul-end> { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 105 , \"excluded_channels(): exclude_mask\" ) ) ; } n ++ ; num_excl_chan += 7 ; } return n ; }",
        "answers": [
            "CWE-119 Fixed Code Lines are: <vul-start> 1 ) { if ( i >= MAX_CHANNELS - num_excl_chan - 7 ) return n ;\n"
        ],
        "ctxs": [
            {
                "id": "2",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (argument_list, ( (ERROR, (declaration_expression, identifier_ld identifier_DEBUGVAR ) ) (argument, (tuple_expression, ( (argument, integer_literal_1 ) , (argument, integer_literal_104 ) , (argument, (string_literal, \" \" ) ) ) ) ) ) ) ) == integer_literal_1 ) { (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_for ) (argument_list, ( (argument, (assignment_expression, identifier_i (assignment_operator, = ) identifier_num_excl_chan ) ) ) ) ) ; ) (expression_statement, (binary_expression, identifier_i < (binary_expression, identifier_num_excl_chan + integer_literal_7 ) ) ; ) (binary_expression, (postfix_unary_expression, identifier_i ++ ) (ERROR, ) ) < (binary_expression, identifier_vul - identifier_end ) ) > { (element_access_expression, (member_access_expression, identifier_drc -> identifier_exclude_mask ) (bracketed_argument_list, [ (argument, identifier_i ) ] ) ) (assignment_operator, =",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "3",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: ) ) > { (element_access_expression, (member_access_expression, identifier_drc -> identifier_exclude_mask ) (bracketed_argument_list, [ (argument, identifier_i ) ] ) ) (assignment_operator, = ) identifier_faad_get1bit ( (ERROR, (declaration_expression, identifier_ld identifier_DEBUGVAR ) ) ( (argument, integer_literal_1 ) , (argument, integer_literal_105 ) , \"",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static uint8_t excluded_channels ( bitfile * ld , drc_info * drc ) { uint8_t i , n = 0 ; uint8_t num_excl_chan = 7 ; for ( i = 0 ; i < 7 ; i ++ ) { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 103 , \"excluded_channels(): exclude_mask\" ) ) ; } n ++ ; while ( ( drc -> additional_excluded_chns [ n - 1 ] = faad_get1bit ( ld DEBUGVAR ( 1 , 104 , \"excluded_channels(): additional_excluded_chns\" ) ) ) == 1 ) { <vul-start> for ( i = num_excl_chan ; i < num_excl_chan + 7 ; i ++ ) <vul-end> { drc -> exclude_mask [ i ] = faad_get1bit ( ld DEBUGVAR ( 1 , 105 , \"excluded_channels(): exclude_mask\" ) ) ; } n ++ ; num_excl_chan += 7 ; } return n ; }",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-119 Name: Improper Restriction of Operations within the Bounds of a Memory Buffer \tDescription: The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:118:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0689::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset value leads to out-of-bounds read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0690::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1532::REFERENCE:CVE-2009-1528:DESCRIPTION:chain: lack of synchronization leads to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1528::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0558::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0269::REFERENCE:CVE-2009-0566:DESCRIPTION:chain: incorrect calculations lead to incorrect pointer dereference and memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0566::REFERENCE:CVE-2009-1350:DESCRIPTION:product accepts crafted messages that lead to a dereference of an arbitrary pointer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1350::REFERENCE:CVE-2009-0191:DESCRIPTION:chain: malformed input causes dereference of uninitialized memory:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0191::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113::REFERENCE:CVE-2005-1513:DESCRIPTION:Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1513::REFERENCE:CVE-2003-0542:DESCRIPTION:buffer overflow involving a regular expression with a large number of captures:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0542::REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000121:: \tPotential Mitigations: ::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "10003",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10004",
                "title": "CWE-125 Vulnerable Code Is: CWE-125 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-125 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10006",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int returnChunkSize ( void * ) { .. . } int main ( ) { <vul-start> .. . memcpy ( destBuf , srcBuf , ( returnChunkSize ( destBuf ) - 1 ) ) ; <vul-end> .. . }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . int size = returnChunkSize ( destBuf ) ; if ( size >= 1 ) { <vul-start> , srcBuf , size <vul-end> - 1 ) <vul-start> - 1 ) ; } <vul-end> .. ."
            },
            {
                "id": "10007",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; char hostname [ 256 ] ; in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10008",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * copy_input ( char * user_supplied_string ) { int i , dst_index ; <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"user string too long, die evil hacker!\" ) ; } dst_index = 0 ; for ( i = 0 ; i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'a' ; dst_buf [ dst_index ++ ] = 'm' ; dst_buf [ dst_index ++ ] = 'p' ; dst_buf [ dst_index ++ ] = ';' ; } else if ( '<' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'l' ; dst_buf [ dst_index ++ ] = 't' ; dst_buf [ dst_index ++ ] = ';' ; } else { <vul-start> dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; <vul-end> } } return dst_buf ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) malloc ( ( 5 * strlen ( user_supplied_string ) + 1 ) <vul-end> * sizeof ( <vul-start> ( char ) <vul-end> ) ; <vul-start> ) { if ( dst_index + 5 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> ) { if ( dst_index + 4 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> else { if ( dst_index + 1 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; <vul-end> return dst_buf"
            },
            {
                "id": "10009",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * trimTrailingWhitespace ( char * strMessage , int length ) { <vul-start> char * retMessage ; <vul-end> <vul-start> char * message = malloc ( sizeof ( char ) * ( length + 1 ) ) ; <vul-end> char message [ length + 1 ] ; int index ; for ( index = 0 ; index < length ; index ++ ) { message [ index ] = strMessage [ index ] ; } message [ index ] = '\\0' ; int len = index - 1 ; while ( len >= 0 && isspace ( message [ len ] ) ) { message [ len ] = '\\0' ; len -- ; } retMessage = malloc ( sizeof ( char ) * ( len + 2 ) ) ; strncpy ( retMessage , message , len + 1 ) ; retMessage [ len + 1 ] = '\\0' ; return retMessage ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> char * retMessage <vul-end> = malloc ( <vul-start> 1 ) ) <vul-end> ; int"
            },
            {
                "id": "10010",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int main ( ) { <vul-start> .. . strncpy ( destBuf , & srcBuf [ find ( srcBuf , ch ) ] , 1024 ) ; <vul-end> <vul-start> .. . } <S2SV_EndBug",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . size_t index = find ( srcBuf , ch ) ; if ( index >= 0 && index < strlen ( srcBuf ) ) { <vul-start> & srcBuf [ index <vul-end> ] , 1024 <vul-start> ) ; } else { strncpy ( destBuf , DEFAULT_VALUE , 1024 ) ; }"
            },
            {
                "id": "10027",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 _StartBug> // char last_name [ 20 ] ; <vul-end> printf ( \" Enter your last name : \" ) ; <vul-start> scanf ( \" % s \" , last_name ) ; <S2SV_EndBug",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> // char last_name [ 256 <vul-end> ] ; <vul-start> ( \" % 255"
            },
            {
                "id": "10028",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 void manipulate_string ( char * string ) { <vul-start> char buf [ 24 ] ; <vul-end> <vul-start> strcpy ( buf , string ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> char buf [ 256 <vul-end> ] ; <vul-start> ] ; strncpy <vul-end> ( buf , <vul-start> buf , string , sizeof ( buf ) - 1"
            },
            {
                "id": "10029",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 char buf [ 24 ] ; printf ( \" Please enter your name and press < Enter > \\n \" ) ; <vul-start> gets ( buf ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; fgets ( buf , sizeof ( buf ) , stdin <vul-end> ) ;"
            },
            {
                "id": "10030",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 .. . struct hostent * clienthp ; char hostname [ MAX_LEN ] ; .. . int count = 0 ; for ( count = 0 ; count < MAX_CONNECTIONS ; count ++ ) { int clientlen = sizeof ( struct sockaddr_in ) ; int clientsocket = accept ( serversocket , ( struct sockaddr * ) & clientaddr , & clientlen ) ; if ( clientsocket >= 0 ) { clienthp = gethostbyaddr ( ( char * ) & clientaddr . sin_addr . s_addr , sizeof ( clientaddr . sin_addr . s_addr ) , AF_INET ) ; <vul-start> .. . close ( clientsocket ) ; <vul-end> } } close ( serversocket ) ;",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; if ( strlen ( clienthp -> h_name ) >= MAX_LEN ) { logOutput ( \"Hostname exceeds maximum length\" ) ; } else { strncpy ( hostname , clienthp -> h_name , MAX_LEN - 1 ) ; hostname [ MAX_LEN - 1 ] = '\\0' ; logOutput ( \"Accepted client connection from host \" , hostname ) ; }"
            },
            {
                "id": "2",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (argument_list, ( (ERROR, (declaration_expression, identifier_ld identifier_DEBUGVAR ) ) (argument, (tuple_expression, ( (argument, integer_literal_1 ) , (argument, integer_literal_104 ) , (argument, (string_literal, \" \" ) ) ) ) ) ) ) ) == integer_literal_1 ) { (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_for ) (argument_list, ( (argument, (assignment_expression, identifier_i (assignment_operator, = ) identifier_num_excl_chan ) ) ) ) ) ; ) (expression_statement, (binary_expression, identifier_i < (binary_expression, identifier_num_excl_chan + integer_literal_7 ) ) ; ) (binary_expression, (postfix_unary_expression, identifier_i ++ ) (ERROR, ) ) < (binary_expression, identifier_vul - identifier_end ) ) > { (element_access_expression, (member_access_expression, identifier_drc -> identifier_exclude_mask ) (bracketed_argument_list, [ (argument, identifier_i ) ] ) ) (assignment_operator, =",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "3",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: ) ) > { (element_access_expression, (member_access_expression, identifier_drc -> identifier_exclude_mask ) (bracketed_argument_list, [ (argument, identifier_i ) ] ) ) (assignment_operator, = ) identifier_faad_get1bit ( (ERROR, (declaration_expression, identifier_ld identifier_DEBUGVAR ) ) ( (argument, integer_literal_1 ) , (argument, integer_literal_105 ) , \"",
                "text": "CWE-119 Fixed Code Lines are:"
            }
        ]
    },
    {
        "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx , <vul-start> int ctrl_id , <vul-end> va_list args ) { <vul-start> vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ; <vul-end> if ( init ) { ctx -> decrypt_cb = init -> decrypt_cb ; ctx -> decrypt_state = init -> decrypt_state ; } else { ctx -> decrypt_cb = NULL ; ctx -> decrypt_state = NULL ; } return VPX_CODEC_OK ; }",
        "answers": [
            "CWE-119 Fixed Code Lines are: <vul-start> * ctx , <vul-end> va_list args ) <vul-start> args ) { vpx_decrypt_init <vul-end> * init = <vul-start> ( args , vpx_decrypt_init <vul-end> * ) ;\n"
        ],
        "ctxs": [
            {
                "id": "102",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (modifier, static_static ) identifier_vpx_codec_err_t identifier_vp8_set_decryptor (parameter_list, ( (parameter, (pointer_type, identifier_vpx_codec_alg_priv_t * ) identifier_ctx ) , (ERROR, < (parameter, identifier_vul (ERROR, - ) identifier_start ) > ) (parameter, predefined_type_int identifier_ctrl_id ) , (ERROR, < ) (parameter, identifier_vul (ERROR, - identifier_end > identifier_va_list ) identifier_args ) ) ) { (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (binary_expression, identifier_vp8_decrypt_init * identifier_init ) ) (assignment_operator, = ) (invocation_expression, identifier_va_arg (argument_list, ( (argument, identifier_args ) , (argument, identifier_vp8_decrypt_init ) (ERROR, * ) ) ) ) ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_if ) (argument_list, ( (argument, identifier_init ) ) ) )",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "103",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_if ) (argument_list, ( (argument, identifier_init ) ) ) ) ; ) { (expression_statement, (assignment_expression, (member_access_expression, identifier_ctx -> identifier_decrypt_cb ) (assignment_operator, = ) (member_access_expression, identifier_init -> identifier_decrypt_cb ) ) ; ) (member_access_expression, identifier_ctx -> identifier_decrypt_state ) (assignment_operator, = ) identifier_init ->",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static vpx_codec_err_t vp8_set_decryptor ( vpx_codec_alg_priv_t * ctx , <vul-start> int ctrl_id , <vul-end> va_list args ) { <vul-start> vp8_decrypt_init * init = va_arg ( args , vp8_decrypt_init * ) ; <vul-end> if ( init ) { ctx -> decrypt_cb = init -> decrypt_cb ; ctx -> decrypt_state = init -> decrypt_state ; } else { ctx -> decrypt_cb = NULL ; ctx -> decrypt_state = NULL ; } return VPX_CODEC_OK ; }",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-119 Name: Improper Restriction of Operations within the Bounds of a Memory Buffer \tDescription: The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:118:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0689::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset value leads to out-of-bounds read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0690::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1532::REFERENCE:CVE-2009-1528:DESCRIPTION:chain: lack of synchronization leads to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1528::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0558::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0269::REFERENCE:CVE-2009-0566:DESCRIPTION:chain: incorrect calculations lead to incorrect pointer dereference and memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0566::REFERENCE:CVE-2009-1350:DESCRIPTION:product accepts crafted messages that lead to a dereference of an arbitrary pointer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1350::REFERENCE:CVE-2009-0191:DESCRIPTION:chain: malformed input causes dereference of uninitialized memory:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0191::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113::REFERENCE:CVE-2005-1513:DESCRIPTION:Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1513::REFERENCE:CVE-2003-0542:DESCRIPTION:buffer overflow involving a regular expression with a large number of captures:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0542::REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000121:: \tPotential Mitigations: ::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "10003",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10004",
                "title": "CWE-125 Vulnerable Code Is: CWE-125 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-125 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10006",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int returnChunkSize ( void * ) { .. . } int main ( ) { <vul-start> .. . memcpy ( destBuf , srcBuf , ( returnChunkSize ( destBuf ) - 1 ) ) ; <vul-end> .. . }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . int size = returnChunkSize ( destBuf ) ; if ( size >= 1 ) { <vul-start> , srcBuf , size <vul-end> - 1 ) <vul-start> - 1 ) ; } <vul-end> .. ."
            },
            {
                "id": "10007",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; char hostname [ 256 ] ; in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10008",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * copy_input ( char * user_supplied_string ) { int i , dst_index ; <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"user string too long, die evil hacker!\" ) ; } dst_index = 0 ; for ( i = 0 ; i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'a' ; dst_buf [ dst_index ++ ] = 'm' ; dst_buf [ dst_index ++ ] = 'p' ; dst_buf [ dst_index ++ ] = ';' ; } else if ( '<' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'l' ; dst_buf [ dst_index ++ ] = 't' ; dst_buf [ dst_index ++ ] = ';' ; } else { <vul-start> dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; <vul-end> } } return dst_buf ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) malloc ( ( 5 * strlen ( user_supplied_string ) + 1 ) <vul-end> * sizeof ( <vul-start> ( char ) <vul-end> ) ; <vul-start> ) { if ( dst_index + 5 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> ) { if ( dst_index + 4 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> else { if ( dst_index + 1 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; <vul-end> return dst_buf"
            },
            {
                "id": "10009",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * trimTrailingWhitespace ( char * strMessage , int length ) { <vul-start> char * retMessage ; <vul-end> <vul-start> char * message = malloc ( sizeof ( char ) * ( length + 1 ) ) ; <vul-end> char message [ length + 1 ] ; int index ; for ( index = 0 ; index < length ; index ++ ) { message [ index ] = strMessage [ index ] ; } message [ index ] = '\\0' ; int len = index - 1 ; while ( len >= 0 && isspace ( message [ len ] ) ) { message [ len ] = '\\0' ; len -- ; } retMessage = malloc ( sizeof ( char ) * ( len + 2 ) ) ; strncpy ( retMessage , message , len + 1 ) ; retMessage [ len + 1 ] = '\\0' ; return retMessage ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> char * retMessage <vul-end> = malloc ( <vul-start> 1 ) ) <vul-end> ; int"
            },
            {
                "id": "10010",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int main ( ) { <vul-start> .. . strncpy ( destBuf , & srcBuf [ find ( srcBuf , ch ) ] , 1024 ) ; <vul-end> <vul-start> .. . } <S2SV_EndBug",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . size_t index = find ( srcBuf , ch ) ; if ( index >= 0 && index < strlen ( srcBuf ) ) { <vul-start> & srcBuf [ index <vul-end> ] , 1024 <vul-start> ) ; } else { strncpy ( destBuf , DEFAULT_VALUE , 1024 ) ; }"
            },
            {
                "id": "10027",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 _StartBug> // char last_name [ 20 ] ; <vul-end> printf ( \" Enter your last name : \" ) ; <vul-start> scanf ( \" % s \" , last_name ) ; <S2SV_EndBug",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> // char last_name [ 256 <vul-end> ] ; <vul-start> ( \" % 255"
            },
            {
                "id": "10028",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 void manipulate_string ( char * string ) { <vul-start> char buf [ 24 ] ; <vul-end> <vul-start> strcpy ( buf , string ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> char buf [ 256 <vul-end> ] ; <vul-start> ] ; strncpy <vul-end> ( buf , <vul-start> buf , string , sizeof ( buf ) - 1"
            },
            {
                "id": "10029",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 char buf [ 24 ] ; printf ( \" Please enter your name and press < Enter > \\n \" ) ; <vul-start> gets ( buf ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; fgets ( buf , sizeof ( buf ) , stdin <vul-end> ) ;"
            },
            {
                "id": "10030",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 .. . struct hostent * clienthp ; char hostname [ MAX_LEN ] ; .. . int count = 0 ; for ( count = 0 ; count < MAX_CONNECTIONS ; count ++ ) { int clientlen = sizeof ( struct sockaddr_in ) ; int clientsocket = accept ( serversocket , ( struct sockaddr * ) & clientaddr , & clientlen ) ; if ( clientsocket >= 0 ) { clienthp = gethostbyaddr ( ( char * ) & clientaddr . sin_addr . s_addr , sizeof ( clientaddr . sin_addr . s_addr ) , AF_INET ) ; <vul-start> .. . close ( clientsocket ) ; <vul-end> } } close ( serversocket ) ;",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; if ( strlen ( clienthp -> h_name ) >= MAX_LEN ) { logOutput ( \"Hostname exceeds maximum length\" ) ; } else { strncpy ( hostname , clienthp -> h_name , MAX_LEN - 1 ) ; hostname [ MAX_LEN - 1 ] = '\\0' ; logOutput ( \"Accepted client connection from host \" , hostname ) ; }"
            },
            {
                "id": "102",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (modifier, static_static ) identifier_vpx_codec_err_t identifier_vp8_set_decryptor (parameter_list, ( (parameter, (pointer_type, identifier_vpx_codec_alg_priv_t * ) identifier_ctx ) , (ERROR, < (parameter, identifier_vul (ERROR, - ) identifier_start ) > ) (parameter, predefined_type_int identifier_ctrl_id ) , (ERROR, < ) (parameter, identifier_vul (ERROR, - identifier_end > identifier_va_list ) identifier_args ) ) ) { (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (binary_expression, identifier_vp8_decrypt_init * identifier_init ) ) (assignment_operator, = ) (invocation_expression, identifier_va_arg (argument_list, ( (argument, identifier_args ) , (argument, identifier_vp8_decrypt_init ) (ERROR, * ) ) ) ) ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_if ) (argument_list, ( (argument, identifier_init ) ) ) )",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "103",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_if ) (argument_list, ( (argument, identifier_init ) ) ) ) ; ) { (expression_statement, (assignment_expression, (member_access_expression, identifier_ctx -> identifier_decrypt_cb ) (assignment_operator, = ) (member_access_expression, identifier_init -> identifier_decrypt_cb ) ) ; ) (member_access_expression, identifier_ctx -> identifier_decrypt_state ) (assignment_operator, = ) identifier_init ->",
                "text": "CWE-119 Fixed Code Lines are:"
            }
        ]
    },
    {
        "question": "CWE-295 Code Input Vulnerable Code Is: CWE-295 <vul-start> void unbind_ports ( void ) { <vul-end> SERVICE_OPTIONS * opt ; s_poll_init ( fds , 1 ) ; <vul-start> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <vul-end> opt = service_options . next ; <vul-start> service_options . next = NULL ; <vul-end> service_free ( & service_options ) ; while ( opt ) { unsigned i ; s_log ( LOG_DEBUG , \"Unbinding service [%s]\" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) unbind_port ( opt , i ) ; if ( opt -> exec_name && opt -> connect_addr . names ) { opt -> option . retry = 0 ; } <vul-start> if ( opt -> ctx ) <vul-end> SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ; s_log ( LOG_DEBUG , \"Service [%s] closed\" , opt -> servname ) ; <vul-start> { <vul-end> SERVICE_OPTIONS * garbage = opt ; opt = opt -> next ; garbage -> next = NULL ; service_free ( garbage ) ; } } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }",
        "answers": [
            "CWE-295 Fixed Code Lines are: <vul-start>       NOEXPORT <vul-start> 1 ) ; for ( <vul-end> opt = service_options <vul-start> . next ; opt ; opt = opt -> next <vul-end> ) { unsigned <vul-start> 0 ; } <vul-end> s_log ( LOG_DEBUG <vul-start> servname ) ; } } <vul-end>      \n"
        ],
        "ctxs": [
            {
                "id": "203",
                "title": "CWE-295 Code Input AST Vulnerable Code Is: (ERROR, < (variable_declaration, identifier_vul (ERROR, - ) (variable_declarator, identifier_start ) ) > ) void_keyword_void identifier_unbind_ports (parameter_list, ( (parameter, identifier_void ) ) ) { (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (binary_expression, identifier_SERVICE_OPTIONS * identifier_opt ) ) ; ) (expression_statement, (invocation_expression, identifier_s_poll_init (argument_list, ( (argument, identifier_fds ) , (argument, integer_literal_1 ) ) ) ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_CRYPTO_THREAD_write_lock ) (argument_list, ( (argument, (element_access_expression, identifier_stunnel_locks (bracketed_argument_list, [ (argument, identifier_LOCK_SECTIONS ) ] ) ) ) ) ) ) ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_opt ) (assignment_operator, = ) (member_access_expression,",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "204",
                "title": "CWE-295 Code Input AST Vulnerable Code Is: ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_opt ) (assignment_operator, = ) (member_access_expression, identifier_service_options . identifier_next ) ) ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (member_access_expression, identifier_service_options . identifier_next ) ) (assignment_operator, = ) identifier_NULL ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_service_free ) (argument_list, ( (argument, (prefix_unary_expression, & identifier_service_options ) ) ) ) ) ; ) while_while ( identifier_opt ) { (local_declaration_statement, (variable_declaration, identifier_unsigned (variable_declarator, identifier_i ) ) ; ) (expression_statement, (invocation_expression, identifier_s_log (argument_list, ( (argument, identifier_LOG_DEBUG ) , (argument, (string_literal, \" \" ) ) , (argument, (member_access_expression, identifier_opt -> identifier_servname ) ) ) ) ) ;",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "205",
                "title": "CWE-295 Code Input AST Vulnerable Code Is: ) , (argument, (string_literal, \" \" ) ) , (argument, (member_access_expression, identifier_opt -> identifier_servname ) ) ) ) ) ; ) (for_statement, for_for ( (assignment_expression, identifier_i (assignment_operator, = ) integer_literal_0 ) ; (binary_expression, identifier_i < (member_access_expression, (member_access_expression, identifier_opt -> identifier_local_addr ) . identifier_num ) ) ; (prefix_unary_expression, ++ identifier_i ) ) (expression_statement, (invocation_expression, identifier_unbind_port (argument_list, ( (argument, identifier_opt ) , (argument, identifier_i ) ) ) ) ; ) ) (if_statement, if_if ( (binary_expression, (member_access_expression, identifier_opt -> identifier_exec_name ) && (member_access_expression, (member_access_expression, identifier_opt -> identifier_connect_addr ) . identifier_names ) ) ) (block, { (expression_statement, (assignment_expression, (member_access_expression, (member_access_expression, identifier_opt -> identifier_option ) . identifier_retry ) (assignment_operator, = ) integer_literal_0 ) ; ) } ) ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression,",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-295 Code Input Vulnerable Code Is: CWE-295 <vul-start> void unbind_ports ( void ) { <vul-end> SERVICE_OPTIONS * opt ; s_poll_init ( fds , 1 ) ; <vul-start> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <vul-end> opt = service_options . next ; <vul-start> service_options . next = NULL ; <vul-end> service_free ( & service_options ) ; while ( opt ) { unsigned i ; s_log ( LOG_DEBUG , \"Unbinding service [%s]\" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) unbind_port ( opt , i ) ; if ( opt -> exec_name && opt -> connect_addr . names ) { opt -> option . retry = 0 ; } <vul-start> if ( opt -> ctx ) <vul-end> SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ; s_log ( LOG_DEBUG , \"Service [%s] closed\" , opt -> servname ) ; <vul-start> { <vul-end> SERVICE_OPTIONS * garbage = opt ; opt = opt -> next ; garbage -> next = NULL ; service_free ( garbage ) ; } } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-295 Name: Improper Certificate Validation \tDescription: The software does not validate, or incorrectly validates, a certificate. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:287:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:287:VIEW ID:1003:ORDINAL:Primary::NATURE:PeerOf:CWE ID:322:VIEW ID:1000:: \tObserved Examples: ::REFERENCE:CVE-2014-1266:DESCRIPTION:chain: incorrect goto in Apple SSL product bypasses certificate validation, allowing MITM attack (Apple goto fail bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266::REFERENCE:CVE-2008-4989:DESCRIPTION:Verification function trusts certificate chains in which the last certificate is self-signed.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4989::REFERENCE:CVE-2012-5821:DESCRIPTION:Web browser uses a TLS-related function incorrectly, preventing it from verifying that a server's certificate is signed by a trusted certification authority (CA):LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5821::REFERENCE:CVE-2009-3046:DESCRIPTION:Web browser does not check if any intermediate certificates are revoked.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3046::REFERENCE:CVE-2011-0199:DESCRIPTION:Operating system does not check Certificate Revocation List (CRL) in some cases, allowing spoofing using a revoked certificate.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0199::REFERENCE:CVE-2012-5810:DESCRIPTION:Mobile banking application does not verify hostname, leading to financial loss.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5810::REFERENCE:CVE-2012-3446:DESCRIPTION:Cloud-support library written in Python uses incorrect regular expression when matching hostname.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-3446::REFERENCE:CVE-2009-2408:DESCRIPTION:Web browser does not correctly handle '0' character (NUL) in Common Name, allowing spoofing of https sites.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2408::REFERENCE:CVE-2012-2993:DESCRIPTION:Smartphone device does not verify hostname, allowing spoofing of mail services.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2993::REFERENCE:CVE-2012-5822:DESCRIPTION:Application uses third-party library that does not validate hostname.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5822::REFERENCE:CVE-2012-5819:DESCRIPTION:Cloud storage management application does not validate hostname.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5819::REFERENCE:CVE-2012-5817:DESCRIPTION:Java library uses JSSE SSLSocket and SSLEngine classes, which do not verify the hostname.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5817::REFERENCE:CVE-2010-1378:DESCRIPTION:chain: incorrect calculation allows attackers to bypass certificate checks.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1378::REFERENCE:CVE-2005-3170:DESCRIPTION:LDAP client accepts certificates even if they are not from a trusted CA.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3170::REFERENCE:CVE-2009-0265:DESCRIPTION:chain: DNS server does not correctly check return value from the OpenSSL EVP_VerifyFinal function allows bypass of validation of the certificate chain.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0265::REFERENCE:CVE-2003-1229:DESCRIPTION:chain: product checks if client is trusted when it intended to check if the server is trusted, allowing validation of signed code.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1229::REFERENCE:CVE-2002-0862:DESCRIPTION:Cryptographic API, as used in web browsers, mail clients, and other software, does not properly validate Basic Constraints.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0862::REFERENCE:CVE-2009-1358:DESCRIPTION:chain: OS package manager does not check properly check the return value, allowing bypass using a revoked certificate.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1358:: \tPotential Mitigations: ::PHASE:Architecture and Design Implementation:DESCRIPTION:Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.::PHASE:Implementation:DESCRIPTION:If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.::",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "10034",
                "title": "CWE-295 Vulnerable Code Is: CWE-295 if ( ( cert = SSL_get_peer_certificate ( ssl ) ) && host ) { foo = SSL_get_verify_result ( ssl ) ; <vul-start> if ( ( X509_V_OK == foo ) || ( X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN == foo ) ) { <vul-end> } }",
                "text": "CWE-295 Fixed Code Lines are: <vul-start> == foo ) && verifyCertificate ( cert , host <vul-end> ) ) {"
            },
            {
                "id": "10035",
                "title": "CWE-295 Vulnerable Code Is: CWE-295 if ( cert = SSL_get_peer_certificate ( ssl ) ) { foo = SSL_get_verify_result ( ssl ) ; <vul-start> if ( ( X509_V_OK == foo ) || ( X509_V_ERR_CERT_HAS_EXPIRED == foo ) ) } <S2SV_EndBug",
                "text": "CWE-295 Fixed Code Lines are: <vul-start> if ( <vul-end> X509_V_OK == foo <vul-start> X509_V_OK == foo && ! is_certificate_expired ( cert <vul-end> ) )"
            },
            {
                "id": "10036",
                "title": "CWE-295 Vulnerable Code Is: CWE-295 if ( cert = SSL_get_peer_certificate ( ssl ) ) { <vul-start> } <S2SV_EndBug",
                "text": "CWE-295 Fixed Code Lines are: <vul-start> ) { int verify_result = SSL_get_verify_result ( ssl ) ; if ( verify_result == X509_V_OK ) { } else { }"
            },
            {
                "id": "10053",
                "title": "CWE-287 Vulnerable Code Is: CWE-287 my $ q = new CGI ; if ( $ q -> cookie ( ' loggedin ' ) ne \" true \" ) { <vul-start> if ( ! AuthenticateUser ( $ q -> param ( ' username ' ) , $ q -> param ( ' password ' ) ) ) { <vul-end> <vul-start> ExitError ( \"Error: invalid username or password\" ) ; <vul-end> } else { <vul-start> # Set loggedin and user cookies . $ q -> cookie ( - name => ' loggedin ' , - value => ' rue ' ) ; <vul-end> <vul-start> $ q -> cookie ( - name => ' ser ' - value => $ q -> param ( ' sername ' ) ; <vul-end> } } <vul-start> if ( $ q -> cookie ( ' ser ' eq \"Administrator\" && $ q -> cookie ( ' oggedin ' eq \"true\" ) { <vul-end> DoAdministratorTasks ( ) ; }",
                "text": "CWE-287 Fixed Code Lines are: <vul-start> if ( ! $ q -> cookie ( ' loggedin ' ) || ! $ q -> cookie ( ' user ' ) ) { ExitError ( \" Error : you need to log in first \" ) ; } elsif ( ! <vul-start> ExitError ( \" Error : invalid username or password \" <vul-end> ) ; <vul-start> # Set loggedin and <vul-end> user cookies . <vul-start> value => ' true <vul-end> ' ) ; <vul-start> name => ' user ' , <vul-end> - value => <vul-start> param ( ' username ' ) <vul-end> ) ; <vul-start> cookie ( ' user ' ) eq \" Administrator \" <vul-end> && $ q <vul-start> cookie ( ' loggedin ' ) eq \" true \" <vul-end> ) {"
            },
            {
                "id": "203",
                "title": "CWE-295 Code Input AST Vulnerable Code Is: (ERROR, < (variable_declaration, identifier_vul (ERROR, - ) (variable_declarator, identifier_start ) ) > ) void_keyword_void identifier_unbind_ports (parameter_list, ( (parameter, identifier_void ) ) ) { (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (binary_expression, identifier_SERVICE_OPTIONS * identifier_opt ) ) ; ) (expression_statement, (invocation_expression, identifier_s_poll_init (argument_list, ( (argument, identifier_fds ) , (argument, integer_literal_1 ) ) ) ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_CRYPTO_THREAD_write_lock ) (argument_list, ( (argument, (element_access_expression, identifier_stunnel_locks (bracketed_argument_list, [ (argument, identifier_LOCK_SECTIONS ) ] ) ) ) ) ) ) ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_opt ) (assignment_operator, = ) (member_access_expression,",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "204",
                "title": "CWE-295 Code Input AST Vulnerable Code Is: ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_opt ) (assignment_operator, = ) (member_access_expression, identifier_service_options . identifier_next ) ) ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (member_access_expression, identifier_service_options . identifier_next ) ) (assignment_operator, = ) identifier_NULL ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_service_free ) (argument_list, ( (argument, (prefix_unary_expression, & identifier_service_options ) ) ) ) ) ; ) while_while ( identifier_opt ) { (local_declaration_statement, (variable_declaration, identifier_unsigned (variable_declarator, identifier_i ) ) ; ) (expression_statement, (invocation_expression, identifier_s_log (argument_list, ( (argument, identifier_LOG_DEBUG ) , (argument, (string_literal, \" \" ) ) , (argument, (member_access_expression, identifier_opt -> identifier_servname ) ) ) ) ) ;",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "205",
                "title": "CWE-295 Code Input AST Vulnerable Code Is: ) , (argument, (string_literal, \" \" ) ) , (argument, (member_access_expression, identifier_opt -> identifier_servname ) ) ) ) ) ; ) (for_statement, for_for ( (assignment_expression, identifier_i (assignment_operator, = ) integer_literal_0 ) ; (binary_expression, identifier_i < (member_access_expression, (member_access_expression, identifier_opt -> identifier_local_addr ) . identifier_num ) ) ; (prefix_unary_expression, ++ identifier_i ) ) (expression_statement, (invocation_expression, identifier_unbind_port (argument_list, ( (argument, identifier_opt ) , (argument, identifier_i ) ) ) ) ; ) ) (if_statement, if_if ( (binary_expression, (member_access_expression, identifier_opt -> identifier_exec_name ) && (member_access_expression, (member_access_expression, identifier_opt -> identifier_connect_addr ) . identifier_names ) ) ) (block, { (expression_statement, (assignment_expression, (member_access_expression, (member_access_expression, identifier_opt -> identifier_option ) . identifier_retry ) (assignment_operator, = ) integer_literal_0 ) ; ) } ) ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression,",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-295 Code Input Vulnerable Code Is: CWE-295 <vul-start> void unbind_ports ( void ) { <vul-end> SERVICE_OPTIONS * opt ; s_poll_init ( fds , 1 ) ; <vul-start> CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <vul-end> opt = service_options . next ; <vul-start> service_options . next = NULL ; <vul-end> service_free ( & service_options ) ; while ( opt ) { unsigned i ; s_log ( LOG_DEBUG , \"Unbinding service [%s]\" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) unbind_port ( opt , i ) ; if ( opt -> exec_name && opt -> connect_addr . names ) { opt -> option . retry = 0 ; } <vul-start> if ( opt -> ctx ) <vul-end> SSL_CTX_flush_sessions ( opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ; s_log ( LOG_DEBUG , \"Service [%s] closed\" , opt -> servname ) ; <vul-start> { <vul-end> SERVICE_OPTIONS * garbage = opt ; opt = opt -> next ; garbage -> next = NULL ; service_free ( garbage ) ; } } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-295 Name: Improper Certificate Validation \tDescription: The software does not validate, or incorrectly validates, a certificate. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:287:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:287:VIEW ID:1003:ORDINAL:Primary::NATURE:PeerOf:CWE ID:322:VIEW ID:1000:: \tObserved Examples: ::REFERENCE:CVE-2014-1266:DESCRIPTION:chain: incorrect goto in Apple SSL product bypasses certificate validation, allowing MITM attack (Apple goto fail bug). CWE-705 (Incorrect Control Flow Scoping) -> CWE-561 (Dead Code) -> CWE-295 (Improper Certificate Validation) -> CWE-393 (Return of Wrong Status Code) -> CWE-300 (Channel Accessible by Non-Endpoint).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-1266::REFERENCE:CVE-2008-4989:DESCRIPTION:Verification function trusts certificate chains in which the last certificate is self-signed.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4989::REFERENCE:CVE-2012-5821:DESCRIPTION:Web browser uses a TLS-related function incorrectly, preventing it from verifying that a server's certificate is signed by a trusted certification authority (CA):LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5821::REFERENCE:CVE-2009-3046:DESCRIPTION:Web browser does not check if any intermediate certificates are revoked.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3046::REFERENCE:CVE-2011-0199:DESCRIPTION:Operating system does not check Certificate Revocation List (CRL) in some cases, allowing spoofing using a revoked certificate.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0199::REFERENCE:CVE-2012-5810:DESCRIPTION:Mobile banking application does not verify hostname, leading to financial loss.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5810::REFERENCE:CVE-2012-3446:DESCRIPTION:Cloud-support library written in Python uses incorrect regular expression when matching hostname.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-3446::REFERENCE:CVE-2009-2408:DESCRIPTION:Web browser does not correctly handle '0' character (NUL) in Common Name, allowing spoofing of https sites.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2408::REFERENCE:CVE-2012-2993:DESCRIPTION:Smartphone device does not verify hostname, allowing spoofing of mail services.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2993::REFERENCE:CVE-2012-5822:DESCRIPTION:Application uses third-party library that does not validate hostname.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5822::REFERENCE:CVE-2012-5819:DESCRIPTION:Cloud storage management application does not validate hostname.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5819::REFERENCE:CVE-2012-5817:DESCRIPTION:Java library uses JSSE SSLSocket and SSLEngine classes, which do not verify the hostname.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-5817::REFERENCE:CVE-2010-1378:DESCRIPTION:chain: incorrect calculation allows attackers to bypass certificate checks.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1378::REFERENCE:CVE-2005-3170:DESCRIPTION:LDAP client accepts certificates even if they are not from a trusted CA.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3170::REFERENCE:CVE-2009-0265:DESCRIPTION:chain: DNS server does not correctly check return value from the OpenSSL EVP_VerifyFinal function allows bypass of validation of the certificate chain.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0265::REFERENCE:CVE-2003-1229:DESCRIPTION:chain: product checks if client is trusted when it intended to check if the server is trusted, allowing validation of signed code.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1229::REFERENCE:CVE-2002-0862:DESCRIPTION:Cryptographic API, as used in web browsers, mail clients, and other software, does not properly validate Basic Constraints.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0862::REFERENCE:CVE-2009-1358:DESCRIPTION:chain: OS package manager does not check properly check the return value, allowing bypass using a revoked certificate.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1358:: \tPotential Mitigations: ::PHASE:Architecture and Design Implementation:DESCRIPTION:Certificates should be carefully managed and checked to assure that data are encrypted with the intended owner's public key.::PHASE:Implementation:DESCRIPTION:If certificate pinning is being used, ensure that all relevant properties of the certificate are fully validated before the certificate is pinned, including the hostname.::",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "10034",
                "title": "CWE-295 Vulnerable Code Is: CWE-295 if ( ( cert = SSL_get_peer_certificate ( ssl ) ) && host ) { foo = SSL_get_verify_result ( ssl ) ; <vul-start> if ( ( X509_V_OK == foo ) || ( X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN == foo ) ) { <vul-end> } }",
                "text": "CWE-295 Fixed Code Lines are: <vul-start> == foo ) && verifyCertificate ( cert , host <vul-end> ) ) {"
            },
            {
                "id": "10035",
                "title": "CWE-295 Vulnerable Code Is: CWE-295 if ( cert = SSL_get_peer_certificate ( ssl ) ) { foo = SSL_get_verify_result ( ssl ) ; <vul-start> if ( ( X509_V_OK == foo ) || ( X509_V_ERR_CERT_HAS_EXPIRED == foo ) ) } <S2SV_EndBug",
                "text": "CWE-295 Fixed Code Lines are: <vul-start> if ( <vul-end> X509_V_OK == foo <vul-start> X509_V_OK == foo && ! is_certificate_expired ( cert <vul-end> ) )"
            },
            {
                "id": "10036",
                "title": "CWE-295 Vulnerable Code Is: CWE-295 if ( cert = SSL_get_peer_certificate ( ssl ) ) { <vul-start> } <S2SV_EndBug",
                "text": "CWE-295 Fixed Code Lines are: <vul-start> ) { int verify_result = SSL_get_verify_result ( ssl ) ; if ( verify_result == X509_V_OK ) { } else { }"
            },
            {
                "id": "10053",
                "title": "CWE-287 Vulnerable Code Is: CWE-287 my $ q = new CGI ; if ( $ q -> cookie ( ' loggedin ' ) ne \" true \" ) { <vul-start> if ( ! AuthenticateUser ( $ q -> param ( ' username ' ) , $ q -> param ( ' password ' ) ) ) { <vul-end> <vul-start> ExitError ( \"Error: invalid username or password\" ) ; <vul-end> } else { <vul-start> # Set loggedin and user cookies . $ q -> cookie ( - name => ' loggedin ' , - value => ' rue ' ) ; <vul-end> <vul-start> $ q -> cookie ( - name => ' ser ' - value => $ q -> param ( ' sername ' ) ; <vul-end> } } <vul-start> if ( $ q -> cookie ( ' ser ' eq \"Administrator\" && $ q -> cookie ( ' oggedin ' eq \"true\" ) { <vul-end> DoAdministratorTasks ( ) ; }",
                "text": "CWE-287 Fixed Code Lines are: <vul-start> if ( ! $ q -> cookie ( ' loggedin ' ) || ! $ q -> cookie ( ' user ' ) ) { ExitError ( \" Error : you need to log in first \" ) ; } elsif ( ! <vul-start> ExitError ( \" Error : invalid username or password \" <vul-end> ) ; <vul-start> # Set loggedin and <vul-end> user cookies . <vul-start> value => ' true <vul-end> ' ) ; <vul-start> name => ' user ' , <vul-end> - value => <vul-start> param ( ' username ' ) <vul-end> ) ; <vul-start> cookie ( ' user ' ) eq \" Administrator \" <vul-end> && $ q <vul-start> cookie ( ' loggedin ' ) eq \" true \" <vul-end> ) {"
            },
            {
                "id": "203",
                "title": "CWE-295 Code Input AST Vulnerable Code Is: (ERROR, < (variable_declaration, identifier_vul (ERROR, - ) (variable_declarator, identifier_start ) ) > ) void_keyword_void identifier_unbind_ports (parameter_list, ( (parameter, identifier_void ) ) ) { (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (binary_expression, identifier_SERVICE_OPTIONS * identifier_opt ) ) ; ) (expression_statement, (invocation_expression, identifier_s_poll_init (argument_list, ( (argument, identifier_fds ) , (argument, integer_literal_1 ) ) ) ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_CRYPTO_THREAD_write_lock ) (argument_list, ( (argument, (element_access_expression, identifier_stunnel_locks (bracketed_argument_list, [ (argument, identifier_LOCK_SECTIONS ) ] ) ) ) ) ) ) ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_opt ) (assignment_operator, = ) (member_access_expression,",
                "text": "CWE-295 Fixed Code Lines are:"
            },
            {
                "id": "204",
                "title": "CWE-295 Code Input AST Vulnerable Code Is: ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_opt ) (assignment_operator, = ) (member_access_expression, identifier_service_options . identifier_next ) ) ; ) (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (member_access_expression, identifier_service_options . identifier_next ) ) (assignment_operator, = ) identifier_NULL ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_service_free ) (argument_list, ( (argument, (prefix_unary_expression, & identifier_service_options ) ) ) ) ) ; ) while_while ( identifier_opt ) { (local_declaration_statement, (variable_declaration, identifier_unsigned (variable_declarator, identifier_i ) ) ; ) (expression_statement, (invocation_expression, identifier_s_log (argument_list, ( (argument, identifier_LOG_DEBUG ) , (argument, (string_literal, \" \" ) ) , (argument, (member_access_expression, identifier_opt -> identifier_servname ) ) ) ) ) ;",
                "text": "CWE-295 Fixed Code Lines are:"
            }
        ]
    },
    {
        "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void nfs4_open_prepare ( struct rpc_task * task , void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state_owner * sp = data -> owner ; if ( nfs_wait_on_sequence ( data -> o_arg . seqid , task ) != 0 ) return ; if ( data -> state != NULL ) { struct nfs_delegation * delegation ; <vul-start> if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <vul-end> goto out_no_action ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( data -> state -> inode ) -> delegation ) ; if ( delegation != NULL && test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) == 0 ) { rcu_read_unlock ( ) ; goto out_no_action ; } rcu_read_unlock ( ) ; } data -> o_arg . id = sp -> so_owner_id . id ; data -> o_arg . clientid = sp -> so_client -> cl_clientid ; if ( data -> o_arg . claim == NFS4_OPEN_CLAIM_PREVIOUS ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_NOATTR ] ; nfs_copy_fh ( & data -> o_res . fh , data -> o_arg . fh ) ; } data -> timestamp = jiffies ; rpc_call_start ( task ) ; return ; out_no_action : task -> tk_action = NULL ; }",
        "answers": [
            "CWE-000 Fixed Code Lines are: <vul-start> -> o_arg . fmode , data -> o_arg . open_flags <vul-end> ) ) goto\n"
        ],
        "ctxs": [
            {
                "id": "302",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: (argument, identifier_task ) ) != integer_literal_0 ) (return_statement, return_return ; ) if_if ( (binary_expression, (member_access_expression, identifier_data -> identifier_state ) != identifier_NULL ) ) { (local_declaration_statement, (variable_declaration, identifier_struct (variable_declarator, identifier_nfs_delegation ) ) ; ) (expression_statement, (prefix_unary_expression, * identifier_delegation ) ; ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_if ) (argument_list, ( (argument, (invocation_expression, identifier_can_open_cached (argument_list, ( (argument, (member_access_expression, identifier_data -> identifier_state ) ) , (argument, (binary_expression, (member_access_expression, (member_access_expression, identifier_data -> identifier_o_arg ) . identifier_open_flags ) & (parenthesized_expression, ( (binary_expression, (binary_expression, identifier_FMODE_READ | identifier_FMODE_WRITE ) | identifier_O_EXCL ) ) ) ) ) ) ) ) ) ) ) ) < (binary_expression, identifier_vul - identifier_end",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "303",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: ) | identifier_O_EXCL ) ) ) ) ) ) ) ) ) ) ) ) < (binary_expression, identifier_vul - identifier_end ) ) > (ERROR, identifier_goto ) identifier_out_no_action ) ; ) (expression_statement, (invocation_expression, identifier_rcu_read_lock (argument_list, ( ) ) ) ; ) identifier_delegation (assignment_operator, = ) identifier_rcu_dereference ( identifier_NFS_I ( (member_access_expression, identifier_data -> identifier_state ) ->",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void nfs4_open_prepare ( struct rpc_task * task , void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state_owner * sp = data -> owner ; if ( nfs_wait_on_sequence ( data -> o_arg . seqid , task ) != 0 ) return ; if ( data -> state != NULL ) { struct nfs_delegation * delegation ; <vul-start> if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <vul-end> goto out_no_action ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( data -> state -> inode ) -> delegation ) ; if ( delegation != NULL && test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) == 0 ) { rcu_read_unlock ( ) ; goto out_no_action ; } rcu_read_unlock ( ) ; } data -> o_arg . id = sp -> so_owner_id . id ; data -> o_arg . clientid = sp -> so_client -> cl_clientid ; if ( data -> o_arg . claim == NFS4_OPEN_CLAIM_PREVIOUS ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_NOATTR ] ; nfs_copy_fh ( & data -> o_res . fh , data -> o_arg . fh ) ; } data -> timestamp = jiffies ; rpc_call_start ( task ) ; return ; out_no_action : task -> tk_action = NULL ; }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-000 Unknown CWE type and no descriptions",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "302",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: (argument, identifier_task ) ) != integer_literal_0 ) (return_statement, return_return ; ) if_if ( (binary_expression, (member_access_expression, identifier_data -> identifier_state ) != identifier_NULL ) ) { (local_declaration_statement, (variable_declaration, identifier_struct (variable_declarator, identifier_nfs_delegation ) ) ; ) (expression_statement, (prefix_unary_expression, * identifier_delegation ) ; ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_if ) (argument_list, ( (argument, (invocation_expression, identifier_can_open_cached (argument_list, ( (argument, (member_access_expression, identifier_data -> identifier_state ) ) , (argument, (binary_expression, (member_access_expression, (member_access_expression, identifier_data -> identifier_o_arg ) . identifier_open_flags ) & (parenthesized_expression, ( (binary_expression, (binary_expression, identifier_FMODE_READ | identifier_FMODE_WRITE ) | identifier_O_EXCL ) ) ) ) ) ) ) ) ) ) ) ) < (binary_expression, identifier_vul - identifier_end",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "303",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: ) | identifier_O_EXCL ) ) ) ) ) ) ) ) ) ) ) ) < (binary_expression, identifier_vul - identifier_end ) ) > (ERROR, identifier_goto ) identifier_out_no_action ) ; ) (expression_statement, (invocation_expression, identifier_rcu_read_lock (argument_list, ( ) ) ) ; ) identifier_delegation (assignment_operator, = ) identifier_rcu_dereference ( identifier_NFS_I ( (member_access_expression, identifier_data -> identifier_state ) ->",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void nfs4_open_prepare ( struct rpc_task * task , void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state_owner * sp = data -> owner ; if ( nfs_wait_on_sequence ( data -> o_arg . seqid , task ) != 0 ) return ; if ( data -> state != NULL ) { struct nfs_delegation * delegation ; <vul-start> if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <vul-end> goto out_no_action ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( data -> state -> inode ) -> delegation ) ; if ( delegation != NULL && test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) == 0 ) { rcu_read_unlock ( ) ; goto out_no_action ; } rcu_read_unlock ( ) ; } data -> o_arg . id = sp -> so_owner_id . id ; data -> o_arg . clientid = sp -> so_client -> cl_clientid ; if ( data -> o_arg . claim == NFS4_OPEN_CLAIM_PREVIOUS ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_NOATTR ] ; nfs_copy_fh ( & data -> o_res . fh , data -> o_arg . fh ) ; } data -> timestamp = jiffies ; rpc_call_start ( task ) ; return ; out_no_action : task -> tk_action = NULL ; }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-000 Unknown CWE type and no descriptions",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "302",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: (argument, identifier_task ) ) != integer_literal_0 ) (return_statement, return_return ; ) if_if ( (binary_expression, (member_access_expression, identifier_data -> identifier_state ) != identifier_NULL ) ) { (local_declaration_statement, (variable_declaration, identifier_struct (variable_declarator, identifier_nfs_delegation ) ) ; ) (expression_statement, (prefix_unary_expression, * identifier_delegation ) ; ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_if ) (argument_list, ( (argument, (invocation_expression, identifier_can_open_cached (argument_list, ( (argument, (member_access_expression, identifier_data -> identifier_state ) ) , (argument, (binary_expression, (member_access_expression, (member_access_expression, identifier_data -> identifier_o_arg ) . identifier_open_flags ) & (parenthesized_expression, ( (binary_expression, (binary_expression, identifier_FMODE_READ | identifier_FMODE_WRITE ) | identifier_O_EXCL ) ) ) ) ) ) ) ) ) ) ) ) < (binary_expression, identifier_vul - identifier_end",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "303",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: ) | identifier_O_EXCL ) ) ) ) ) ) ) ) ) ) ) ) < (binary_expression, identifier_vul - identifier_end ) ) > (ERROR, identifier_goto ) identifier_out_no_action ) ; ) (expression_statement, (invocation_expression, identifier_rcu_read_lock (argument_list, ( ) ) ) ; ) identifier_delegation (assignment_operator, = ) identifier_rcu_dereference ( identifier_NFS_I ( (member_access_expression, identifier_data -> identifier_state ) ->",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void nfs4_open_prepare ( struct rpc_task * task , void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state_owner * sp = data -> owner ; if ( nfs_wait_on_sequence ( data -> o_arg . seqid , task ) != 0 ) return ; if ( data -> state != NULL ) { struct nfs_delegation * delegation ; <vul-start> if ( can_open_cached ( data -> state , data -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ) ) <vul-end> goto out_no_action ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( data -> state -> inode ) -> delegation ) ; if ( delegation != NULL && test_bit ( NFS_DELEGATION_NEED_RECLAIM , & delegation -> flags ) == 0 ) { rcu_read_unlock ( ) ; goto out_no_action ; } rcu_read_unlock ( ) ; } data -> o_arg . id = sp -> so_owner_id . id ; data -> o_arg . clientid = sp -> so_client -> cl_clientid ; if ( data -> o_arg . claim == NFS4_OPEN_CLAIM_PREVIOUS ) { task -> tk_msg . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_OPEN_NOATTR ] ; nfs_copy_fh ( & data -> o_res . fh , data -> o_arg . fh ) ; } data -> timestamp = jiffies ; rpc_call_start ( task ) ; return ; out_no_action : task -> tk_action = NULL ; }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-000 Unknown CWE type and no descriptions",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            }
        ]
    },
    {
        "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 cJSON * cJSON_CreateTrue ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_True ; return item ; }",
        "answers": [
            "CWE-119 Fixed Code Lines are: \n"
        ],
        "ctxs": [
            {
                "id": "401",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (pointer_type, identifier_cJSON * ) identifier_cJSON_CreateTrue (parameter_list, ( (parameter, identifier_void ) ) ) { (expression_statement, (assignment_expression, (binary_expression, identifier_cJSON * identifier_item ) (assignment_operator, = ) (invocation_expression, identifier_cJSON_New_Item (argument_list, ( ) ) ) ) ; ) if_if ( identifier_item ) (member_access_expression, identifier_item -> identifier_type ) (assignment_operator, = )",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-119 Code Input Vulnerable Code Is: CWE-119 cJSON * cJSON_CreateTrue ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_True ; return item ; }",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-119 Name: Improper Restriction of Operations within the Bounds of a Memory Buffer \tDescription: The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:118:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0689::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset value leads to out-of-bounds read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0690::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1532::REFERENCE:CVE-2009-1528:DESCRIPTION:chain: lack of synchronization leads to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1528::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0558::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0269::REFERENCE:CVE-2009-0566:DESCRIPTION:chain: incorrect calculations lead to incorrect pointer dereference and memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0566::REFERENCE:CVE-2009-1350:DESCRIPTION:product accepts crafted messages that lead to a dereference of an arbitrary pointer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1350::REFERENCE:CVE-2009-0191:DESCRIPTION:chain: malformed input causes dereference of uninitialized memory:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0191::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113::REFERENCE:CVE-2005-1513:DESCRIPTION:Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1513::REFERENCE:CVE-2003-0542:DESCRIPTION:buffer overflow involving a regular expression with a large number of captures:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0542::REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000121:: \tPotential Mitigations: ::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "10003",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10004",
                "title": "CWE-125 Vulnerable Code Is: CWE-125 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-125 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10006",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int returnChunkSize ( void * ) { .. . } int main ( ) { <vul-start> .. . memcpy ( destBuf , srcBuf , ( returnChunkSize ( destBuf ) - 1 ) ) ; <vul-end> .. . }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . int size = returnChunkSize ( destBuf ) ; if ( size >= 1 ) { <vul-start> , srcBuf , size <vul-end> - 1 ) <vul-start> - 1 ) ; } <vul-end> .. ."
            },
            {
                "id": "10007",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; char hostname [ 256 ] ; in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10008",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * copy_input ( char * user_supplied_string ) { int i , dst_index ; <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"user string too long, die evil hacker!\" ) ; } dst_index = 0 ; for ( i = 0 ; i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'a' ; dst_buf [ dst_index ++ ] = 'm' ; dst_buf [ dst_index ++ ] = 'p' ; dst_buf [ dst_index ++ ] = ';' ; } else if ( '<' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'l' ; dst_buf [ dst_index ++ ] = 't' ; dst_buf [ dst_index ++ ] = ';' ; } else { <vul-start> dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; <vul-end> } } return dst_buf ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) malloc ( ( 5 * strlen ( user_supplied_string ) + 1 ) <vul-end> * sizeof ( <vul-start> ( char ) <vul-end> ) ; <vul-start> ) { if ( dst_index + 5 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> ) { if ( dst_index + 4 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> else { if ( dst_index + 1 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; <vul-end> return dst_buf"
            },
            {
                "id": "10009",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * trimTrailingWhitespace ( char * strMessage , int length ) { <vul-start> char * retMessage ; <vul-end> <vul-start> char * message = malloc ( sizeof ( char ) * ( length + 1 ) ) ; <vul-end> char message [ length + 1 ] ; int index ; for ( index = 0 ; index < length ; index ++ ) { message [ index ] = strMessage [ index ] ; } message [ index ] = '\\0' ; int len = index - 1 ; while ( len >= 0 && isspace ( message [ len ] ) ) { message [ len ] = '\\0' ; len -- ; } retMessage = malloc ( sizeof ( char ) * ( len + 2 ) ) ; strncpy ( retMessage , message , len + 1 ) ; retMessage [ len + 1 ] = '\\0' ; return retMessage ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> char * retMessage <vul-end> = malloc ( <vul-start> 1 ) ) <vul-end> ; int"
            },
            {
                "id": "10010",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int main ( ) { <vul-start> .. . strncpy ( destBuf , & srcBuf [ find ( srcBuf , ch ) ] , 1024 ) ; <vul-end> <vul-start> .. . } <S2SV_EndBug",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . size_t index = find ( srcBuf , ch ) ; if ( index >= 0 && index < strlen ( srcBuf ) ) { <vul-start> & srcBuf [ index <vul-end> ] , 1024 <vul-start> ) ; } else { strncpy ( destBuf , DEFAULT_VALUE , 1024 ) ; }"
            },
            {
                "id": "10027",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 _StartBug> // char last_name [ 20 ] ; <vul-end> printf ( \" Enter your last name : \" ) ; <vul-start> scanf ( \" % s \" , last_name ) ; <S2SV_EndBug",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> // char last_name [ 256 <vul-end> ] ; <vul-start> ( \" % 255"
            },
            {
                "id": "10028",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 void manipulate_string ( char * string ) { <vul-start> char buf [ 24 ] ; <vul-end> <vul-start> strcpy ( buf , string ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> char buf [ 256 <vul-end> ] ; <vul-start> ] ; strncpy <vul-end> ( buf , <vul-start> buf , string , sizeof ( buf ) - 1"
            },
            {
                "id": "10029",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 char buf [ 24 ] ; printf ( \" Please enter your name and press < Enter > \\n \" ) ; <vul-start> gets ( buf ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; fgets ( buf , sizeof ( buf ) , stdin <vul-end> ) ;"
            },
            {
                "id": "10030",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 .. . struct hostent * clienthp ; char hostname [ MAX_LEN ] ; .. . int count = 0 ; for ( count = 0 ; count < MAX_CONNECTIONS ; count ++ ) { int clientlen = sizeof ( struct sockaddr_in ) ; int clientsocket = accept ( serversocket , ( struct sockaddr * ) & clientaddr , & clientlen ) ; if ( clientsocket >= 0 ) { clienthp = gethostbyaddr ( ( char * ) & clientaddr . sin_addr . s_addr , sizeof ( clientaddr . sin_addr . s_addr ) , AF_INET ) ; <vul-start> .. . close ( clientsocket ) ; <vul-end> } } close ( serversocket ) ;",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; if ( strlen ( clienthp -> h_name ) >= MAX_LEN ) { logOutput ( \"Hostname exceeds maximum length\" ) ; } else { strncpy ( hostname , clienthp -> h_name , MAX_LEN - 1 ) ; hostname [ MAX_LEN - 1 ] = '\\0' ; logOutput ( \"Accepted client connection from host \" , hostname ) ; }"
            },
            {
                "id": "401",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (pointer_type, identifier_cJSON * ) identifier_cJSON_CreateTrue (parameter_list, ( (parameter, identifier_void ) ) ) { (expression_statement, (assignment_expression, (binary_expression, identifier_cJSON * identifier_item ) (assignment_operator, = ) (invocation_expression, identifier_cJSON_New_Item (argument_list, ( ) ) ) ) ; ) if_if ( identifier_item ) (member_access_expression, identifier_item -> identifier_type ) (assignment_operator, = )",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-119 Code Input Vulnerable Code Is: CWE-119 cJSON * cJSON_CreateTrue ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_True ; return item ; }",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-119 Name: Improper Restriction of Operations within the Bounds of a Memory Buffer \tDescription: The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:118:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0689::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset value leads to out-of-bounds read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0690::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1532::REFERENCE:CVE-2009-1528:DESCRIPTION:chain: lack of synchronization leads to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1528::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0558::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0269::REFERENCE:CVE-2009-0566:DESCRIPTION:chain: incorrect calculations lead to incorrect pointer dereference and memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0566::REFERENCE:CVE-2009-1350:DESCRIPTION:product accepts crafted messages that lead to a dereference of an arbitrary pointer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1350::REFERENCE:CVE-2009-0191:DESCRIPTION:chain: malformed input causes dereference of uninitialized memory:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0191::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113::REFERENCE:CVE-2005-1513:DESCRIPTION:Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1513::REFERENCE:CVE-2003-0542:DESCRIPTION:buffer overflow involving a regular expression with a large number of captures:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0542::REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000121:: \tPotential Mitigations: ::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::",
                "text": "CWE-119 Fixed Code Lines are:"
            }
        ]
    },
    {
        "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_rtcd ( ) { <vul-start> vpx_scale_rtcd ( ) ; <vul-end> once ( setup_rtcd_internal ) ; }",
        "answers": [
            "CWE-119 Fixed Code Lines are: <vul-start> ( ) { <vul-end> once ( setup_rtcd_internal\n"
        ],
        "ctxs": [
            {
                "id": "501",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (compilation_unit, (method_declaration, void_keyword_void identifier_vp8_rtcd (parameter_list, ( ) ) (block, { (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_vpx_scale_rtcd ) (argument_list, ( ) ) ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_once ) (argument_list, ( (argument, identifier_setup_rtcd_internal ) ) ) ) ; ) } ) ) )",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_rtcd ( ) { <vul-start> vpx_scale_rtcd ( ) ; <vul-end> once ( setup_rtcd_internal ) ; }",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-119 Name: Improper Restriction of Operations within the Bounds of a Memory Buffer \tDescription: The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:118:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0689::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset value leads to out-of-bounds read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0690::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1532::REFERENCE:CVE-2009-1528:DESCRIPTION:chain: lack of synchronization leads to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1528::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0558::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0269::REFERENCE:CVE-2009-0566:DESCRIPTION:chain: incorrect calculations lead to incorrect pointer dereference and memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0566::REFERENCE:CVE-2009-1350:DESCRIPTION:product accepts crafted messages that lead to a dereference of an arbitrary pointer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1350::REFERENCE:CVE-2009-0191:DESCRIPTION:chain: malformed input causes dereference of uninitialized memory:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0191::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113::REFERENCE:CVE-2005-1513:DESCRIPTION:Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1513::REFERENCE:CVE-2003-0542:DESCRIPTION:buffer overflow involving a regular expression with a large number of captures:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0542::REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000121:: \tPotential Mitigations: ::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "10003",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10004",
                "title": "CWE-125 Vulnerable Code Is: CWE-125 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-125 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10006",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int returnChunkSize ( void * ) { .. . } int main ( ) { <vul-start> .. . memcpy ( destBuf , srcBuf , ( returnChunkSize ( destBuf ) - 1 ) ) ; <vul-end> .. . }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . int size = returnChunkSize ( destBuf ) ; if ( size >= 1 ) { <vul-start> , srcBuf , size <vul-end> - 1 ) <vul-start> - 1 ) ; } <vul-end> .. ."
            },
            {
                "id": "10007",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; char hostname [ 256 ] ; in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10008",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * copy_input ( char * user_supplied_string ) { int i , dst_index ; <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"user string too long, die evil hacker!\" ) ; } dst_index = 0 ; for ( i = 0 ; i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'a' ; dst_buf [ dst_index ++ ] = 'm' ; dst_buf [ dst_index ++ ] = 'p' ; dst_buf [ dst_index ++ ] = ';' ; } else if ( '<' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'l' ; dst_buf [ dst_index ++ ] = 't' ; dst_buf [ dst_index ++ ] = ';' ; } else { <vul-start> dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; <vul-end> } } return dst_buf ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) malloc ( ( 5 * strlen ( user_supplied_string ) + 1 ) <vul-end> * sizeof ( <vul-start> ( char ) <vul-end> ) ; <vul-start> ) { if ( dst_index + 5 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> ) { if ( dst_index + 4 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> else { if ( dst_index + 1 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; <vul-end> return dst_buf"
            },
            {
                "id": "10009",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * trimTrailingWhitespace ( char * strMessage , int length ) { <vul-start> char * retMessage ; <vul-end> <vul-start> char * message = malloc ( sizeof ( char ) * ( length + 1 ) ) ; <vul-end> char message [ length + 1 ] ; int index ; for ( index = 0 ; index < length ; index ++ ) { message [ index ] = strMessage [ index ] ; } message [ index ] = '\\0' ; int len = index - 1 ; while ( len >= 0 && isspace ( message [ len ] ) ) { message [ len ] = '\\0' ; len -- ; } retMessage = malloc ( sizeof ( char ) * ( len + 2 ) ) ; strncpy ( retMessage , message , len + 1 ) ; retMessage [ len + 1 ] = '\\0' ; return retMessage ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> char * retMessage <vul-end> = malloc ( <vul-start> 1 ) ) <vul-end> ; int"
            },
            {
                "id": "10010",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int main ( ) { <vul-start> .. . strncpy ( destBuf , & srcBuf [ find ( srcBuf , ch ) ] , 1024 ) ; <vul-end> <vul-start> .. . } <S2SV_EndBug",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . size_t index = find ( srcBuf , ch ) ; if ( index >= 0 && index < strlen ( srcBuf ) ) { <vul-start> & srcBuf [ index <vul-end> ] , 1024 <vul-start> ) ; } else { strncpy ( destBuf , DEFAULT_VALUE , 1024 ) ; }"
            },
            {
                "id": "10027",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 _StartBug> // char last_name [ 20 ] ; <vul-end> printf ( \" Enter your last name : \" ) ; <vul-start> scanf ( \" % s \" , last_name ) ; <S2SV_EndBug",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> // char last_name [ 256 <vul-end> ] ; <vul-start> ( \" % 255"
            },
            {
                "id": "10028",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 void manipulate_string ( char * string ) { <vul-start> char buf [ 24 ] ; <vul-end> <vul-start> strcpy ( buf , string ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> char buf [ 256 <vul-end> ] ; <vul-start> ] ; strncpy <vul-end> ( buf , <vul-start> buf , string , sizeof ( buf ) - 1"
            },
            {
                "id": "10029",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 char buf [ 24 ] ; printf ( \" Please enter your name and press < Enter > \\n \" ) ; <vul-start> gets ( buf ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; fgets ( buf , sizeof ( buf ) , stdin <vul-end> ) ;"
            },
            {
                "id": "10030",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 .. . struct hostent * clienthp ; char hostname [ MAX_LEN ] ; .. . int count = 0 ; for ( count = 0 ; count < MAX_CONNECTIONS ; count ++ ) { int clientlen = sizeof ( struct sockaddr_in ) ; int clientsocket = accept ( serversocket , ( struct sockaddr * ) & clientaddr , & clientlen ) ; if ( clientsocket >= 0 ) { clienthp = gethostbyaddr ( ( char * ) & clientaddr . sin_addr . s_addr , sizeof ( clientaddr . sin_addr . s_addr ) , AF_INET ) ; <vul-start> .. . close ( clientsocket ) ; <vul-end> } } close ( serversocket ) ;",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; if ( strlen ( clienthp -> h_name ) >= MAX_LEN ) { logOutput ( \"Hostname exceeds maximum length\" ) ; } else { strncpy ( hostname , clienthp -> h_name , MAX_LEN - 1 ) ; hostname [ MAX_LEN - 1 ] = '\\0' ; logOutput ( \"Accepted client connection from host \" , hostname ) ; }"
            },
            {
                "id": "501",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (compilation_unit, (method_declaration, void_keyword_void identifier_vp8_rtcd (parameter_list, ( ) ) (block, { (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_vpx_scale_rtcd ) (argument_list, ( ) ) ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > identifier_once ) (argument_list, ( (argument, identifier_setup_rtcd_internal ) ) ) ) ; ) } ) ) )",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-119 Code Input Vulnerable Code Is: CWE-119 void vp8_rtcd ( ) { <vul-start> vpx_scale_rtcd ( ) ; <vul-end> once ( setup_rtcd_internal ) ; }",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-119 Name: Improper Restriction of Operations within the Bounds of a Memory Buffer \tDescription: The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:118:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0689::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset value leads to out-of-bounds read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0690::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1532::REFERENCE:CVE-2009-1528:DESCRIPTION:chain: lack of synchronization leads to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1528::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0558::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0269::REFERENCE:CVE-2009-0566:DESCRIPTION:chain: incorrect calculations lead to incorrect pointer dereference and memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0566::REFERENCE:CVE-2009-1350:DESCRIPTION:product accepts crafted messages that lead to a dereference of an arbitrary pointer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1350::REFERENCE:CVE-2009-0191:DESCRIPTION:chain: malformed input causes dereference of uninitialized memory:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0191::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113::REFERENCE:CVE-2005-1513:DESCRIPTION:Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1513::REFERENCE:CVE-2003-0542:DESCRIPTION:buffer overflow involving a regular expression with a large number of captures:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0542::REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000121:: \tPotential Mitigations: ::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::",
                "text": "CWE-119 Fixed Code Lines are:"
            }
        ]
    },
    {
        "question": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int parse_device ( dev_t * pdev , struct archive * a , char * val ) { # define MAX_PACK_ARGS 3 unsigned long numbers [ MAX_PACK_ARGS ] ; char * p , * dev ; int argc ; pack_t * pack ; dev_t result ; const char * error = NULL ; memset ( pdev , 0 , sizeof ( * pdev ) ) ; if ( ( dev = strchr ( val , ',' ) ) != NULL ) { * dev ++ = '\\\\0' ; if ( ( pack = pack_find ( val ) ) == NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Unknown format `%s\\'\" , val ) ; return ARCHIVE_WARN ; } argc = 0 ; while ( ( p = la_strsep ( & dev , \",\" ) ) != NULL ) { if ( * p == '\\\\0' ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Missing number\" ) ; return ARCHIVE_WARN ; } <vul-start> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <vul-end> <vul-start> if ( argc > MAX_PACK_ARGS ) { <vul-end> archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Too many arguments\" ) ; return ARCHIVE_WARN ; } } if ( argc < 2 ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Not enough arguments\" ) ; return ARCHIVE_WARN ; } result = ( * pack ) ( argc , numbers , & error ) ; if ( error != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"%s\" , error ) ; return ARCHIVE_WARN ; } }",
        "answers": [
            "CWE-119 Fixed Code Lines are: <vul-start> ARCHIVE_WARN ; } if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Too many arguments\" ) ; return ARCHIVE_WARN ; } <vul-start> p ) ; <vul-end> } if (\n"
        ],
        "ctxs": [
            {
                "id": "601",
                "title": "CWE-119 Code Input Vulnerable Code Is: != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"%s\" , error ) ; return ARCHIVE_WARN ; } } else { result = ( dev_t ) mtree_atol ( & val ) ; } * pdev = result ; return ARCHIVE_OK ; # undef MAX_PACK_ARGS }",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "602",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (argument_list, ( (argument, identifier_a ) , (argument, identifier_ARCHIVE_ERRNO_FILE_FORMAT ) , (argument, (string_literal, \" \" ) ) ) ) ; (return_statement, return_return identifier_ARCHIVE_WARN ; ) } (ERROR, < ) (expression_statement, (assignment_expression, (element_access_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > identifier_numbers ) (bracketed_argument_list, [ (argument, (postfix_unary_expression, identifier_argc ++ ) ) ] ) ) (assignment_operator, = ) (ERROR, (parameter_list, ( (parameter, identifier_unsigned identifier_long ) ) ) ) (invocation_expression, identifier_mtree_atol (argument_list, ( (argument, (prefix_unary_expression, & identifier_p ) ) ) ) ) ) ; ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, (invocation_expression, (binary_expression, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (ERROR, < ) (binary_expression, identifier_vul - identifier_start ) ) > identifier_if ) (argument_list, (",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "603",
                "title": "CWE-119 Code Input AST Vulnerable Code Is: (binary_expression, identifier_vul - identifier_end ) > (ERROR, < ) (binary_expression, identifier_vul - identifier_start ) ) > identifier_if ) (argument_list, ( (argument, (binary_expression, identifier_argc > identifier_MAX_PACK_ARGS ) ) ) ) ) (ERROR, { ) < (binary_expression, identifier_vul - identifier_end ) ) > identifier_archive_set_error ) (argument_list, ( (argument, identifier_a ) , (argument, identifier_ARCHIVE_ERRNO_FILE_FORMAT ) , (argument, (string_literal, \" \" ) ) ) ) ) ; ) (return_statement, return_return identifier_ARCHIVE_WARN ; )",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-119 Code Input Vulnerable Code Is: CWE-119 static int parse_device ( dev_t * pdev , struct archive * a , char * val ) { # define MAX_PACK_ARGS 3 unsigned long numbers [ MAX_PACK_ARGS ] ; char * p , * dev ; int argc ; pack_t * pack ; dev_t result ; const char * error = NULL ; memset ( pdev , 0 , sizeof ( * pdev ) ) ; if ( ( dev = strchr ( val , ',' ) ) != NULL ) { * dev ++ = '\\\\0' ; if ( ( pack = pack_find ( val ) ) == NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Unknown format `%s\\'\" , val ) ; return ARCHIVE_WARN ; } argc = 0 ; while ( ( p = la_strsep ( & dev , \",\" ) ) != NULL ) { if ( * p == '\\\\0' ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Missing number\" ) ; return ARCHIVE_WARN ; } <vul-start> numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; <vul-end> <vul-start> if ( argc > MAX_PACK_ARGS ) { <vul-end> archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Too many arguments\" ) ; return ARCHIVE_WARN ; } } if ( argc < 2 ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"Not enough arguments\" ) ; return ARCHIVE_WARN ; } result = ( * pack ) ( argc , numbers , & error ) ; if ( error != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"%s\" , error ) ; return ARCHIVE_WARN ; } }",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-119 Name: Improper Restriction of Operations within the Bounds of a Memory Buffer \tDescription: The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:118:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2009-2550:DESCRIPTION:Classic stack-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2550::REFERENCE:CVE-2009-2403:DESCRIPTION:Heap-based buffer overflow in media player using a long entry in a playlist:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2403::REFERENCE:CVE-2009-0689:DESCRIPTION:large precision value in a format string triggers overflow:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0689::REFERENCE:CVE-2009-0690:DESCRIPTION:negative offset value leads to out-of-bounds read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0690::REFERENCE:CVE-2009-1532:DESCRIPTION:malformed inputs cause accesses of uninitialized or previously-deleted objects, leading to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1532::REFERENCE:CVE-2009-1528:DESCRIPTION:chain: lack of synchronization leads to memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1528::REFERENCE:CVE-2009-0558:DESCRIPTION:attacker-controlled array index leads to code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0558::REFERENCE:CVE-2009-0269:DESCRIPTION:chain: -1 value from a function call was intended to indicate an error, but is used as an array index instead.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0269::REFERENCE:CVE-2009-0566:DESCRIPTION:chain: incorrect calculations lead to incorrect pointer dereference and memory corruption:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0566::REFERENCE:CVE-2009-1350:DESCRIPTION:product accepts crafted messages that lead to a dereference of an arbitrary pointer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1350::REFERENCE:CVE-2009-0191:DESCRIPTION:chain: malformed input causes dereference of uninitialized memory:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0191::REFERENCE:CVE-2008-4113:DESCRIPTION:OS kernel trusts userland-supplied length value, allowing reading of sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4113::REFERENCE:CVE-2005-1513:DESCRIPTION:Chain: integer overflow in securely-coded mail program leads to buffer overflow. In 2005, this was regarded as unrealistic to exploit, but in 2020, it was rediscovered to be easier to exploit due to evolutions of the technology.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1513::REFERENCE:CVE-2003-0542:DESCRIPTION:buffer overflow involving a regular expression with a large number of captures:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0542::REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000121:: \tPotential Mitigations: ::PHASE:Requirements:STRATEGY:Language Selection:DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].:EFFECTIVENESS:Defense in Depth::PHASE:Operation:STRATEGY:Environment Hardening:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].:EFFECTIVENESS:Defense in Depth::PHASE:Implementation:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.:EFFECTIVENESS:Moderate::",
                "text": "CWE-119 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "10003",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10004",
                "title": "CWE-125 Vulnerable Code Is: CWE-125 int getValueFromArray ( int * array , int len , int index ) { int value ; <vul-start> if ( index < len ) { <vul-end> value = array [ index ] ; } else { <vul-start> printf ( \"Value is: %d\\n\" , array [ index ] ) ; <vul-end> value = - 1 ; } return value ; }",
                "text": "CWE-125 Fixed Code Lines are: <vul-start> if ( index >= 0 && index <vul-start> else { if ( index < 0 ) { printf ( \"Invalid array index: Negative value\\n\" ) ; } else { printf ( \"Invalid array index: Out of range\\n\" ) ; } <vul-end> value ="
            },
            {
                "id": "10006",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int returnChunkSize ( void * ) { .. . } int main ( ) { <vul-start> .. . memcpy ( destBuf , srcBuf , ( returnChunkSize ( destBuf ) - 1 ) ) ; <vul-end> .. . }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . int size = returnChunkSize ( destBuf ) ; if ( size >= 1 ) { <vul-start> , srcBuf , size <vul-end> - 1 ) <vul-start> - 1 ) ; } <vul-end> .. ."
            },
            {
                "id": "10007",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; char hostname [ 256 ] ; in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10008",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * copy_input ( char * user_supplied_string ) { int i , dst_index ; <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"user string too long, die evil hacker!\" ) ; } dst_index = 0 ; for ( i = 0 ; i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'a' ; dst_buf [ dst_index ++ ] = 'm' ; dst_buf [ dst_index ++ ] = 'p' ; dst_buf [ dst_index ++ ] = ';' ; } else if ( '<' == user_supplied_string [ i ] ) { <vul-start> dst_buf [ dst_index ++ ] = '&' ; <vul-end> dst_buf [ dst_index ++ ] = 'l' ; dst_buf [ dst_index ++ ] = 't' ; dst_buf [ dst_index ++ ] = ';' ; } else { <vul-start> dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; <vul-end> } } return dst_buf ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> ) malloc ( ( 5 * strlen ( user_supplied_string ) + 1 ) <vul-end> * sizeof ( <vul-start> ( char ) <vul-end> ) ; <vul-start> ) { if ( dst_index + 5 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> ) { if ( dst_index + 4 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } <vul-start> else { if ( dst_index + 1 >= ( 5 * strlen ( user_supplied_string ) + 1 ) ) { die ( \"destination buffer too small, abort encoding!\" ) ; } dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; <vul-end> return dst_buf"
            },
            {
                "id": "10009",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 char * trimTrailingWhitespace ( char * strMessage , int length ) { <vul-start> char * retMessage ; <vul-end> <vul-start> char * message = malloc ( sizeof ( char ) * ( length + 1 ) ) ; <vul-end> char message [ length + 1 ] ; int index ; for ( index = 0 ; index < length ; index ++ ) { message [ index ] = strMessage [ index ] ; } message [ index ] = '\\0' ; int len = index - 1 ; while ( len >= 0 && isspace ( message [ len ] ) ) { message [ len ] = '\\0' ; len -- ; } retMessage = malloc ( sizeof ( char ) * ( len + 2 ) ) ; strncpy ( retMessage , message , len + 1 ) ; retMessage [ len + 1 ] = '\\0' ; return retMessage ; }",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> char * retMessage <vul-end> = malloc ( <vul-start> 1 ) ) <vul-end> ; int"
            },
            {
                "id": "10010",
                "title": "CWE-787 Vulnerable Code Is: CWE-787 int main ( ) { <vul-start> .. . strncpy ( destBuf , & srcBuf [ find ( srcBuf , ch ) ] , 1024 ) ; <vul-end> <vul-start> .. . } <S2SV_EndBug",
                "text": "CWE-787 Fixed Code Lines are: <vul-start> .. . size_t index = find ( srcBuf , ch ) ; if ( index >= 0 && index < strlen ( srcBuf ) ) { <vul-start> & srcBuf [ index <vul-end> ] , 1024 <vul-start> ) ; } else { strncpy ( destBuf , DEFAULT_VALUE , 1024 ) ; }"
            },
            {
                "id": "10027",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 _StartBug> // char last_name [ 20 ] ; <vul-end> printf ( \" Enter your last name : \" ) ; <vul-start> scanf ( \" % s \" , last_name ) ; <S2SV_EndBug",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> // char last_name [ 256 <vul-end> ] ; <vul-start> ( \" % 255"
            },
            {
                "id": "10028",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 void manipulate_string ( char * string ) { <vul-start> char buf [ 24 ] ; <vul-end> <vul-start> strcpy ( buf , string ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> char buf [ 256 <vul-end> ] ; <vul-start> ] ; strncpy <vul-end> ( buf , <vul-start> buf , string , sizeof ( buf ) - 1"
            },
            {
                "id": "10029",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 char buf [ 24 ] ; printf ( \" Please enter your name and press < Enter > \\n \" ) ; <vul-start> gets ( buf ) ; <vul-end> .. . }",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; fgets ( buf , sizeof ( buf ) , stdin <vul-end> ) ;"
            },
            {
                "id": "10030",
                "title": "CWE-120 Vulnerable Code Is: CWE-120 .. . struct hostent * clienthp ; char hostname [ MAX_LEN ] ; .. . int count = 0 ; for ( count = 0 ; count < MAX_CONNECTIONS ; count ++ ) { int clientlen = sizeof ( struct sockaddr_in ) ; int clientsocket = accept ( serversocket , ( struct sockaddr * ) & clientaddr , & clientlen ) ; if ( clientsocket >= 0 ) { clienthp = gethostbyaddr ( ( char * ) & clientaddr . sin_addr . s_addr , sizeof ( clientaddr . sin_addr . s_addr ) , AF_INET ) ; <vul-start> .. . close ( clientsocket ) ; <vul-end> } } close ( serversocket ) ;",
                "text": "CWE-120 Fixed Code Lines are: <vul-start> ) ; if ( strlen ( clienthp -> h_name ) >= MAX_LEN ) { logOutput ( \"Hostname exceeds maximum length\" ) ; } else { strncpy ( hostname , clienthp -> h_name , MAX_LEN - 1 ) ; hostname [ MAX_LEN - 1 ] = '\\0' ; logOutput ( \"Accepted client connection from host \" , hostname ) ; }"
            },
            {
                "id": "601",
                "title": "CWE-119 Code Input Vulnerable Code Is: != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , \"%s\" , error ) ; return ARCHIVE_WARN ; } } else { result = ( dev_t ) mtree_atol ( & val ) ; } * pdev = result ; return ARCHIVE_OK ; # undef MAX_PACK_ARGS }",
                "text": "CWE-119 Fixed Code Lines are:"
            }
        ]
    },
    {
        "question": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size >> inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; cur_logical = index << ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , PAGEVEC_SIZE ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; BUG_ON ( ! PageLocked ( page ) ) ; BUG_ON ( PageWriteback ( page ) ) ; BUG_ON ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do",
        "answers": [
            "CWE-000 Fixed Code Lines are: <vul-start> pblock ) ; if ( buffer_uninit ( exbh ) ) set_buffer_uninit ( bh ) ;\n"
        ],
        "ctxs": [
            {
                "id": "701",
                "title": "CWE-000 Code Input Vulnerable Code Is: break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do { if ( cur_logical >= logical + blocks ) break ; if ( buffer_delay ( bh ) || buffer_unwritten ( bh ) ) { BUG_ON ( bh -> b_bdev != inode -> i_sb -> s_bdev ) ; if ( buffer_delay ( bh ) ) { clear_buffer_delay ( bh ) ; bh -> b_blocknr = pblock ; } else { clear_buffer_unwritten ( bh ) ; BUG_ON ( bh -> b_blocknr != pblock ) ; } } else if ( buffer_mapped ( bh ) ) BUG_ON ( bh -> b_blocknr != pblock ) ; <vul-start> cur_logical ++ ; <vul-end> pblock ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; } pagevec_release ( & pvec ) ; } }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "702",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: != identifier_pblock ) ; } } else_else (if_statement, if_if ( (invocation_expression, identifier_buffer_mapped (argument_list, ( (argument, identifier_bh ) ) ) ) ) (expression_statement, (invocation_expression, identifier_BUG_ON (argument_list, ( (argument, (binary_expression, (member_access_expression, identifier_bh -> identifier_b_blocknr ) != identifier_pblock ) ) ) ) ) ; ) ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (postfix_unary_expression, identifier_cur_logical ++ ) ) ; ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (postfix_unary_expression, identifier_pblock ++ ) ) ; ) } while_while ( (binary_expression, (parenthesized_expression, ( (assignment_expression, identifier_bh (assignment_operator, = ) (member_access_expression, identifier_bh -> identifier_b_this_page ) ) ) ) != identifier_head ) ) ; } (expression_statement, (invocation_expression, identifier_pagevec_release (argument_list, ( (argument,",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "703",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: (member_access_expression, identifier_bh -> identifier_b_this_page ) ) ) ) != identifier_head ) ) ; } (expression_statement, (invocation_expression, identifier_pagevec_release (argument_list, ( (argument, (prefix_unary_expression, & identifier_pvec ) ) ) ) ) ; ) } }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size >> inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; cur_logical = index << ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , PAGEVEC_SIZE ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; BUG_ON ( ! PageLocked ( page ) ) ; BUG_ON ( PageWriteback ( page ) ) ; BUG_ON ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-000 Unknown CWE type and no descriptions",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "701",
                "title": "CWE-000 Code Input Vulnerable Code Is: break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do { if ( cur_logical >= logical + blocks ) break ; if ( buffer_delay ( bh ) || buffer_unwritten ( bh ) ) { BUG_ON ( bh -> b_bdev != inode -> i_sb -> s_bdev ) ; if ( buffer_delay ( bh ) ) { clear_buffer_delay ( bh ) ; bh -> b_blocknr = pblock ; } else { clear_buffer_unwritten ( bh ) ; BUG_ON ( bh -> b_blocknr != pblock ) ; } } else if ( buffer_mapped ( bh ) ) BUG_ON ( bh -> b_blocknr != pblock ) ; <vul-start> cur_logical ++ ; <vul-end> pblock ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; } pagevec_release ( & pvec ) ; } }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "702",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: != identifier_pblock ) ; } } else_else (if_statement, if_if ( (invocation_expression, identifier_buffer_mapped (argument_list, ( (argument, identifier_bh ) ) ) ) ) (expression_statement, (invocation_expression, identifier_BUG_ON (argument_list, ( (argument, (binary_expression, (member_access_expression, identifier_bh -> identifier_b_blocknr ) != identifier_pblock ) ) ) ) ) ; ) ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (postfix_unary_expression, identifier_cur_logical ++ ) ) ; ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (postfix_unary_expression, identifier_pblock ++ ) ) ; ) } while_while ( (binary_expression, (parenthesized_expression, ( (assignment_expression, identifier_bh (assignment_operator, = ) (member_access_expression, identifier_bh -> identifier_b_this_page ) ) ) ) != identifier_head ) ) ; } (expression_statement, (invocation_expression, identifier_pagevec_release (argument_list, ( (argument,",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "703",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: (member_access_expression, identifier_bh -> identifier_b_this_page ) ) ) ) != identifier_head ) ) ; } (expression_statement, (invocation_expression, identifier_pagevec_release (argument_list, ( (argument, (prefix_unary_expression, & identifier_pvec ) ) ) ) ) ; ) } }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size >> inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; cur_logical = index << ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , PAGEVEC_SIZE ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; BUG_ON ( ! PageLocked ( page ) ) ; BUG_ON ( PageWriteback ( page ) ) ; BUG_ON ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-000 Unknown CWE type and no descriptions",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "10000",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 void host_lookup ( char * user_supplied_addr ) { struct hostent * hp ; in_addr_t * addr ; <vul-start> char hostname [ 64 ] ; <vul-end> in_addr_t inet_addr ( const char * cp ) ; validate_addr_form ( user_supplied_addr ) ; addr = inet_addr ( user_supplied_addr ) ; hp = gethostbyaddr ( addr , sizeof ( struct in_addr ) , AF_INET ) ; <vul-start> strcpy ( hostname , hp -> h_name ) ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> char hostname [ 256 <vul-end> ] ; <vul-start> ) ; strncpy <vul-end> ( hostname , <vul-start> hp -> h_name , sizeof ( hostname ) - 1 ) ; hostname [ sizeof ( hostname ) - 1 ] = '\\0' <vul-end> ; }"
            },
            {
                "id": "10001",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 char * copy_input ( const char * user_supplied_string ) { <vul-start> int i , dst_index ; <vul-end> <vul-start> char * dst_buf = ( char * ) malloc ( 4 * sizeof ( char ) * MAX_SIZE ) ; <vul-end> if ( MAX_SIZE <= strlen ( user_supplied_string ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_index = 0 ; <vul-start> for ( int i = 0 ; <vul-end> i < strlen ( user_supplied_string ) ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) { <vul-start> if ( dst_index + 5 > encoded_length ) { <vul-end> die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&amp;\" ) ; dst_index += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { if ( dst_index + 4 > encoded_length ) { die ( \"Encoded string buffer overflow, aborting!\" ) ; } strcpy ( dst_buf + dst_index , \"&lt;\" ) ; dst_index += 4 ; } else { dst_buf [ dst_index ++ ] = user_supplied_string [ i ] ; } } dst_buf [ dst_index ] = '\\0' ; return dst_buf ; }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) { size_t input_length = strlen ( user_supplied_string ) ; size_t encoded_length = 0 <vul-end> ; char <vul-start> char * dst_buf ; for ( size_t i <vul-end> = 0 ; <vul-start> 0 ; i < input_length <vul-end> ; i <vul-start> ) { encoded_length += 5 ; } else if ( '<' == user_supplied_string [ i ] ) { encoded_length += 4 ; } else { encoded_length += 1 ; } } if ( encoded_length >= ( 4 * MAX_SIZE ) ) { die ( \"Encoded string too long, aborting!\" ) ; } dst_buf = ( char * ) malloc ( ( encoded_length + 1 ) * sizeof ( char ) ) ; size_t dst_index = 0 ; for ( size_t i = 0 ; i < input_length ; i ++ ) { if ( '&' == user_supplied_string [ i ] ) {"
            },
            {
                "id": "10002",
                "title": "CWE-119 Vulnerable Code Is: CWE-119 int main ( int argc , char * * argv ) { char * items [ ] = { \"boat\" , \"car\" , \"truck\" , \"train\" } ; int num_items = sizeof ( items ) / sizeof ( items [ 0 ] ) ; int index = GetUntrustedOffset ( ) ; <vul-start> printf ( \"You selected %s\\n\" , items [ index - 1 ] ) ; <vul-end> <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-119 Fixed Code Lines are: <vul-start> ) ; if ( index >= 1 && index <= num_items ) { <vul-start> ) ; } else { printf ( \"Invalid offset specified\\n\" ) ; }"
            },
            {
                "id": "701",
                "title": "CWE-000 Code Input Vulnerable Code Is: break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do { if ( cur_logical >= logical + blocks ) break ; if ( buffer_delay ( bh ) || buffer_unwritten ( bh ) ) { BUG_ON ( bh -> b_bdev != inode -> i_sb -> s_bdev ) ; if ( buffer_delay ( bh ) ) { clear_buffer_delay ( bh ) ; bh -> b_blocknr = pblock ; } else { clear_buffer_unwritten ( bh ) ; BUG_ON ( bh -> b_blocknr != pblock ) ; } } else if ( buffer_mapped ( bh ) ) BUG_ON ( bh -> b_blocknr != pblock ) ; <vul-start> cur_logical ++ ; <vul-end> pblock ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; } pagevec_release ( & pvec ) ; } }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "702",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: != identifier_pblock ) ; } } else_else (if_statement, if_if ( (invocation_expression, identifier_buffer_mapped (argument_list, ( (argument, identifier_bh ) ) ) ) ) (expression_statement, (invocation_expression, identifier_BUG_ON (argument_list, ( (argument, (binary_expression, (member_access_expression, identifier_bh -> identifier_b_blocknr ) != identifier_pblock ) ) ) ) ) ; ) ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (postfix_unary_expression, identifier_cur_logical ++ ) ) ; ) (ERROR, < ) (expression_statement, (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (postfix_unary_expression, identifier_pblock ++ ) ) ; ) } while_while ( (binary_expression, (parenthesized_expression, ( (assignment_expression, identifier_bh (assignment_operator, = ) (member_access_expression, identifier_bh -> identifier_b_this_page ) ) ) ) != identifier_head ) ) ; } (expression_statement, (invocation_expression, identifier_pagevec_release (argument_list, ( (argument,",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "703",
                "title": "CWE-000 Code Input AST Vulnerable Code Is: (member_access_expression, identifier_bh -> identifier_b_this_page ) ) ) ) != identifier_head ) ) ; } (expression_statement, (invocation_expression, identifier_pagevec_release (argument_list, ( (argument, (prefix_unary_expression, & identifier_pvec ) ) ) ) ) ; ) } }",
                "text": "CWE-000 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-000 Code Input Vulnerable Code Is: CWE-000 static void mpage_put_bnr_to_bhs ( struct mpage_da_data * mpd , sector_t logical , struct buffer_head * exbh ) { struct inode * inode = mpd -> inode ; struct address_space * mapping = inode -> i_mapping ; int blocks = exbh -> b_size >> inode -> i_blkbits ; sector_t pblock = exbh -> b_blocknr , cur_logical ; struct buffer_head * head , * bh ; pgoff_t index , end ; struct pagevec pvec ; int nr_pages , i ; index = logical >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; end = ( logical + blocks - 1 ) >> ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; cur_logical = index << ( PAGE_CACHE_SHIFT - inode -> i_blkbits ) ; pagevec_init ( & pvec , 0 ) ; while ( index <= end ) { nr_pages = pagevec_lookup ( & pvec , mapping , index , PAGEVEC_SIZE ) ; if ( nr_pages == 0 ) break ; for ( i = 0 ; i < nr_pages ; i ++ ) { struct page * page = pvec . pages [ i ] ; index = page -> index ; if ( index > end ) break ; index ++ ; BUG_ON ( ! PageLocked ( page ) ) ; BUG_ON ( PageWriteback ( page ) ) ; BUG_ON ( ! page_has_buffers ( page ) ) ; bh = page_buffers ( page ) ; head = bh ; do { if ( cur_logical >= logical ) break ; cur_logical ++ ; } while ( ( bh = bh -> b_this_page ) != head ) ; do",
                "text": "CWE-000 Fixed Code Lines are:"
            }
        ]
    },
    {
        "question": "CWE-362 Code Input Vulnerable Code Is: CWE-362 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , \"tty_ioctl\" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p",
        "answers": [
            "CWE-362 Fixed Code Lines are: <vul-start> TIOCGETD : return tiocgetd ( tty , <vul-end> p ) ;\n"
        ],
        "ctxs": [
            {
                "id": "801",
                "title": "CWE-362 Code Input Vulnerable Code Is: ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <vul-start> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <vul-end> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 )",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "802",
                "title": "CWE-362 Code Input Vulnerable Code Is: ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "802",
                "title": "CWE-362 Code Input AST Vulnerable Code Is: , (argument, identifier_real_tty ) , (argument, identifier_p ) ) ; (switch_section, (case_switch_label, case_case identifier_TIOCGSID : ) (return_statement, return_return (invocation_expression, identifier_tiocgsid (argument_list, ( (argument, identifier_tty ) , (argument, identifier_real_tty ) , (argument, identifier_p ) ) ) ) ; ) ) (switch_section, (case_switch_label, case_case identifier_TIOCGETD : ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (ERROR, identifier_return ) identifier_put_user ) (argument_list, ( (argument, (member_access_expression, (member_access_expression, (member_access_expression, identifier_tty -> identifier_ldisc ) -> identifier_ops ) -> identifier_num ) ) , (argument, (cast_expression, ( (pointer_type, predefined_type_int (ERROR, identifier___user ) * ) ) identifier_p ) ) ) ) ) ; ) (ERROR, < (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (ERROR, identifier_case",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "803",
                "title": "CWE-362 Code Input AST Vulnerable Code Is: ) identifier_p ) ) ) ) ) ; ) (ERROR, < (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (ERROR, identifier_case ) identifier_TIOCSETD ) : ) (return_statement, return_return (invocation_expression, identifier_tiocsetd (argument_list, ( (argument, identifier_tty ) , (argument, identifier_p ) ) ) ) ; ) ) (case_switch_label, case_case identifier_TIOCVHANGUP : ) if_if ( (invocation_expression, (prefix_unary_expression, ! identifier_capable ) (argument_list, ( (argument, identifier_CAP_SYS_ADMIN ) ) ) )",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-362 Code Input Vulnerable Code Is: CWE-362 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , \"tty_ioctl\" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-362 Name: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') \tDescription: The program contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:691:VIEW ID:1000:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2019-18827:DESCRIPTION:chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18827::REFERENCE:CVE-2008-5044:DESCRIPTION:Race condition leading to a crash by calling a hook removal procedure while other activities are occurring at the same time.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5044::REFERENCE:CVE-2008-2958:DESCRIPTION:chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2958::REFERENCE:CVE-2008-1570:DESCRIPTION:chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1570::REFERENCE:CVE-2008-0058:DESCRIPTION:Unsynchronized caching operation enables a race condition that causes messages to be sent to a deallocated object.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0058::REFERENCE:CVE-2008-0379:DESCRIPTION:Race condition during initialization triggers a buffer overflow.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0379::REFERENCE:CVE-2007-6599:DESCRIPTION:Daemon crash by quickly performing operations and undoing them, which eventually leads to an operation that does not acquire a lock.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6599::REFERENCE:CVE-2007-6180:DESCRIPTION:chain: race condition triggers NULL pointer dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6180::REFERENCE:CVE-2007-5794:DESCRIPTION:Race condition in library function could cause data to be sent to the wrong process.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5794::REFERENCE:CVE-2007-3970:DESCRIPTION:Race condition in file parser leads to heap corruption.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3970::REFERENCE:CVE-2008-5021:DESCRIPTION:chain: race condition allows attacker to access an object while it is still being initialized, causing software to access uninitialized memory.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5021::REFERENCE:CVE-2009-4895:DESCRIPTION:chain: race condition for an argument value, possibly resulting in NULL dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4895::REFERENCE:CVE-2009-3547:DESCRIPTION:chain: race condition might allow resource to be released before operating on it, leading to NULL dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3547:: \tPotential Mitigations: ::PHASE:Architecture and Design:DESCRIPTION:In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.::PHASE:Architecture and Design:DESCRIPTION:Use thread-safe capabilities such as the data access abstraction in Spring.::PHASE:Architecture and Design:DESCRIPTION:Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring. Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).::PHASE:Implementation:DESCRIPTION:When using multithreading and operating on shared variables, only use thread-safe functions.::PHASE:Implementation:DESCRIPTION:Use atomic operations on shared variables. Be wary of innocent-looking constructs such as x++. This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.::PHASE:Implementation:DESCRIPTION:Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.::PHASE:Implementation:DESCRIPTION:Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.::PHASE:Implementation:DESCRIPTION:Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.::PHASE:Implementation:DESCRIPTION:Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "10016",
                "title": "CWE-362 Vulnerable Code Is: CWE-362 _StartBug> // void f ( pthread_mutex_t * mutex ) { <vul-end> <vul-start> + pthread_mutex_lock ( mutex ) ; <vul-end> <vul-start> pthread_mutex_unlock ( mutex ) ; <vul-end> <vul-start> + } <S2SV_EndBug",
                "text": "CWE-362 Fixed Code Lines are: <vul-start> // int <vul-end> f ( pthread_mutex_t <vul-start> ) { int result ; + result = <vul-end> pthread_mutex_lock ( mutex <vul-start> ) ; if ( result != 0 ) { return result ; } result = <vul-start> ) ; if ( result != 0 ) { return result ; } + return 0 ; <vul-end> }"
            },
            {
                "id": "801",
                "title": "CWE-362 Code Input Vulnerable Code Is: ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <vul-start> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <vul-end> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 )",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "802",
                "title": "CWE-362 Code Input Vulnerable Code Is: ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "802",
                "title": "CWE-362 Code Input AST Vulnerable Code Is: , (argument, identifier_real_tty ) , (argument, identifier_p ) ) ; (switch_section, (case_switch_label, case_case identifier_TIOCGSID : ) (return_statement, return_return (invocation_expression, identifier_tiocgsid (argument_list, ( (argument, identifier_tty ) , (argument, identifier_real_tty ) , (argument, identifier_p ) ) ) ) ; ) ) (switch_section, (case_switch_label, case_case identifier_TIOCGETD : ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (ERROR, identifier_return ) identifier_put_user ) (argument_list, ( (argument, (member_access_expression, (member_access_expression, (member_access_expression, identifier_tty -> identifier_ldisc ) -> identifier_ops ) -> identifier_num ) ) , (argument, (cast_expression, ( (pointer_type, predefined_type_int (ERROR, identifier___user ) * ) ) identifier_p ) ) ) ) ) ; ) (ERROR, < (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (ERROR, identifier_case",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "803",
                "title": "CWE-362 Code Input AST Vulnerable Code Is: ) identifier_p ) ) ) ) ) ; ) (ERROR, < (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (ERROR, identifier_case ) identifier_TIOCSETD ) : ) (return_statement, return_return (invocation_expression, identifier_tiocsetd (argument_list, ( (argument, identifier_tty ) , (argument, identifier_p ) ) ) ) ; ) ) (case_switch_label, case_case identifier_TIOCVHANGUP : ) if_if ( (invocation_expression, (prefix_unary_expression, ! identifier_capable ) (argument_list, ( (argument, identifier_CAP_SYS_ADMIN ) ) ) )",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-362 Code Input Vulnerable Code Is: CWE-362 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , \"tty_ioctl\" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-362 Name: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') \tDescription: The program contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:691:VIEW ID:1000:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2019-18827:DESCRIPTION:chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18827::REFERENCE:CVE-2008-5044:DESCRIPTION:Race condition leading to a crash by calling a hook removal procedure while other activities are occurring at the same time.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5044::REFERENCE:CVE-2008-2958:DESCRIPTION:chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2958::REFERENCE:CVE-2008-1570:DESCRIPTION:chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1570::REFERENCE:CVE-2008-0058:DESCRIPTION:Unsynchronized caching operation enables a race condition that causes messages to be sent to a deallocated object.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0058::REFERENCE:CVE-2008-0379:DESCRIPTION:Race condition during initialization triggers a buffer overflow.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0379::REFERENCE:CVE-2007-6599:DESCRIPTION:Daemon crash by quickly performing operations and undoing them, which eventually leads to an operation that does not acquire a lock.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6599::REFERENCE:CVE-2007-6180:DESCRIPTION:chain: race condition triggers NULL pointer dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6180::REFERENCE:CVE-2007-5794:DESCRIPTION:Race condition in library function could cause data to be sent to the wrong process.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5794::REFERENCE:CVE-2007-3970:DESCRIPTION:Race condition in file parser leads to heap corruption.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3970::REFERENCE:CVE-2008-5021:DESCRIPTION:chain: race condition allows attacker to access an object while it is still being initialized, causing software to access uninitialized memory.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5021::REFERENCE:CVE-2009-4895:DESCRIPTION:chain: race condition for an argument value, possibly resulting in NULL dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4895::REFERENCE:CVE-2009-3547:DESCRIPTION:chain: race condition might allow resource to be released before operating on it, leading to NULL dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3547:: \tPotential Mitigations: ::PHASE:Architecture and Design:DESCRIPTION:In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.::PHASE:Architecture and Design:DESCRIPTION:Use thread-safe capabilities such as the data access abstraction in Spring.::PHASE:Architecture and Design:DESCRIPTION:Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring. Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).::PHASE:Implementation:DESCRIPTION:When using multithreading and operating on shared variables, only use thread-safe functions.::PHASE:Implementation:DESCRIPTION:Use atomic operations on shared variables. Be wary of innocent-looking constructs such as x++. This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.::PHASE:Implementation:DESCRIPTION:Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.::PHASE:Implementation:DESCRIPTION:Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.::PHASE:Implementation:DESCRIPTION:Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.::PHASE:Implementation:DESCRIPTION:Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "10016",
                "title": "CWE-362 Vulnerable Code Is: CWE-362 _StartBug> // void f ( pthread_mutex_t * mutex ) { <vul-end> <vul-start> + pthread_mutex_lock ( mutex ) ; <vul-end> <vul-start> pthread_mutex_unlock ( mutex ) ; <vul-end> <vul-start> + } <S2SV_EndBug",
                "text": "CWE-362 Fixed Code Lines are: <vul-start> // int <vul-end> f ( pthread_mutex_t <vul-start> ) { int result ; + result = <vul-end> pthread_mutex_lock ( mutex <vul-start> ) ; if ( result != 0 ) { return result ; } result = <vul-start> ) ; if ( result != 0 ) { return result ; } + return 0 ; <vul-end> }"
            },
            {
                "id": "801",
                "title": "CWE-362 Code Input Vulnerable Code Is: ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p ) ; } case TIOCNOTTY : if ( current -> signal -> tty != tty ) return - ENOTTY ; no_tty ( ) ; return 0 ; case TIOCSCTTY : return tiocsctty ( real_tty , file , arg ) ; case TIOCGPGRP : return tiocgpgrp ( tty , real_tty , p ) ; case TIOCSPGRP : return tiocspgrp ( tty , real_tty , p ) ; case TIOCGSID : return tiocgsid ( tty , real_tty , p ) ; case TIOCGETD : <vul-start> return put_user ( tty -> ldisc -> ops -> num , ( int __user * ) p ) ; <vul-end> case TIOCSETD : return tiocsetd ( tty , p ) ; case TIOCVHANGUP : if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; tty_vhangup ( tty ) ; return 0 ; case TIOCGDEV : { unsigned int ret = new_encode_dev ( tty_devnum ( real_tty ) ) ; return put_user ( ret , ( unsigned int __user * ) p ) ; } case TIOCSBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , - 1 ) ; return 0 ; case TIOCCBRK : if ( tty -> ops -> break_ctl ) return tty -> ops -> break_ctl ( tty , 0 ) ; return 0 ; case TCSBRK : if ( ! arg ) return send_break ( tty , 250 ) ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 )",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "802",
                "title": "CWE-362 Code Input Vulnerable Code Is: ; return 0 ; case TCSBRKP : return send_break ( tty , arg ? arg * 100 : 250 ) ; case TIOCMGET : return tty_tiocmget ( tty , p ) ; case TIOCMSET : case TIOCMBIC : case TIOCMBIS : return tty_tiocmset ( tty , cmd , p ) ; case TIOCGICOUNT : retval = tty_tiocgicount ( tty , p ) ; if ( retval != - EINVAL ) return retval ; break ; case TCFLSH : switch ( arg ) { case TCIFLUSH : case TCIOFLUSH : tty_buffer_flush ( tty , NULL ) ; break ; } break ; case TIOCSSERIAL : tty_warn_deprecated_flags ( p ) ; break ; } if ( tty -> ops -> ioctl ) { retval = tty -> ops -> ioctl ( tty , cmd , arg ) ; if ( retval != - ENOIOCTLCMD ) return retval ; } ld = tty_ldisc_ref_wait ( tty ) ; retval = - EINVAL ; if ( ld -> ops -> ioctl ) { retval = ld -> ops -> ioctl ( tty , file , cmd , arg ) ; if ( retval == - ENOIOCTLCMD ) retval = - ENOTTY ; } tty_ldisc_deref ( ld ) ; return retval ; }",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "802",
                "title": "CWE-362 Code Input AST Vulnerable Code Is: , (argument, identifier_real_tty ) , (argument, identifier_p ) ) ; (switch_section, (case_switch_label, case_case identifier_TIOCGSID : ) (return_statement, return_return (invocation_expression, identifier_tiocgsid (argument_list, ( (argument, identifier_tty ) , (argument, identifier_real_tty ) , (argument, identifier_p ) ) ) ) ; ) ) (switch_section, (case_switch_label, case_case identifier_TIOCGETD : ) (ERROR, < ) (expression_statement, (invocation_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (ERROR, identifier_return ) identifier_put_user ) (argument_list, ( (argument, (member_access_expression, (member_access_expression, (member_access_expression, identifier_tty -> identifier_ldisc ) -> identifier_ops ) -> identifier_num ) ) , (argument, (cast_expression, ( (pointer_type, predefined_type_int (ERROR, identifier___user ) * ) ) identifier_p ) ) ) ) ) ; ) (ERROR, < (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (ERROR, identifier_case",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "803",
                "title": "CWE-362 Code Input AST Vulnerable Code Is: ) identifier_p ) ) ) ) ) ; ) (ERROR, < (binary_expression, (binary_expression, identifier_vul - identifier_end ) > (ERROR, identifier_case ) identifier_TIOCSETD ) : ) (return_statement, return_return (invocation_expression, identifier_tiocsetd (argument_list, ( (argument, identifier_tty ) , (argument, identifier_p ) ) ) ) ; ) ) (case_switch_label, case_case identifier_TIOCVHANGUP : ) if_if ( (invocation_expression, (prefix_unary_expression, ! identifier_capable ) (argument_list, ( (argument, identifier_CAP_SYS_ADMIN ) ) ) )",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-362 Code Input Vulnerable Code Is: CWE-362 long tty_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct tty_struct * tty = file_tty ( file ) ; struct tty_struct * real_tty ; void __user * p = ( void __user * ) arg ; int retval ; struct tty_ldisc * ld ; if ( tty_paranoia_check ( tty , file_inode ( file ) , \"tty_ioctl\" ) ) return - EINVAL ; real_tty = tty_pair_get_tty ( tty ) ; switch ( cmd ) { case TIOCSETD : case TIOCSBRK : case TIOCCBRK : case TCSBRK : case TCSBRKP : retval = tty_check_change ( tty ) ; if ( retval ) return retval ; if ( cmd != TIOCCBRK ) { tty_wait_until_sent ( tty , 0 ) ; if ( signal_pending ( current ) ) return - EINTR ; } break ; } switch ( cmd ) { case TIOCSTI : return tiocsti ( tty , p ) ; case TIOCGWINSZ : return tiocgwinsz ( real_tty , p ) ; case TIOCSWINSZ : return tiocswinsz ( real_tty , p ) ; case TIOCCONS : return real_tty != tty ? - EINVAL : tioccons ( file ) ; case FIONBIO : return fionbio ( file , p ) ; case TIOCEXCL : set_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCNXCL : clear_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return 0 ; case TIOCGEXCL : { int excl = test_bit ( TTY_EXCLUSIVE , & tty -> flags ) ; return put_user ( excl , ( int __user * ) p",
                "text": "CWE-362 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-362 Name: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition') \tDescription: The program contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently. \tRelated Weaknesses: ::NATURE:ChildOf:CWE ID:691:VIEW ID:1000:ORDINAL:Primary:: \tObserved Examples: ::REFERENCE:CVE-2019-18827:DESCRIPTION:chain: JTAG interface is not disabled (CWE-1191) during ROM code execution, introducing a race condition (CWE-362) to extract encryption keys:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18827::REFERENCE:CVE-2008-5044:DESCRIPTION:Race condition leading to a crash by calling a hook removal procedure while other activities are occurring at the same time.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5044::REFERENCE:CVE-2008-2958:DESCRIPTION:chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2958::REFERENCE:CVE-2008-1570:DESCRIPTION:chain: time-of-check time-of-use (TOCTOU) race condition in program allows bypass of protection mechanism that was designed to prevent symlink attacks.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1570::REFERENCE:CVE-2008-0058:DESCRIPTION:Unsynchronized caching operation enables a race condition that causes messages to be sent to a deallocated object.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0058::REFERENCE:CVE-2008-0379:DESCRIPTION:Race condition during initialization triggers a buffer overflow.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0379::REFERENCE:CVE-2007-6599:DESCRIPTION:Daemon crash by quickly performing operations and undoing them, which eventually leads to an operation that does not acquire a lock.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6599::REFERENCE:CVE-2007-6180:DESCRIPTION:chain: race condition triggers NULL pointer dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6180::REFERENCE:CVE-2007-5794:DESCRIPTION:Race condition in library function could cause data to be sent to the wrong process.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5794::REFERENCE:CVE-2007-3970:DESCRIPTION:Race condition in file parser leads to heap corruption.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3970::REFERENCE:CVE-2008-5021:DESCRIPTION:chain: race condition allows attacker to access an object while it is still being initialized, causing software to access uninitialized memory.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5021::REFERENCE:CVE-2009-4895:DESCRIPTION:chain: race condition for an argument value, possibly resulting in NULL dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-4895::REFERENCE:CVE-2009-3547:DESCRIPTION:chain: race condition might allow resource to be released before operating on it, leading to NULL dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3547:: \tPotential Mitigations: ::PHASE:Architecture and Design:DESCRIPTION:In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance.::PHASE:Architecture and Design:DESCRIPTION:Use thread-safe capabilities such as the data access abstraction in Spring.::PHASE:Architecture and Design:DESCRIPTION:Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring. Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400).::PHASE:Implementation:DESCRIPTION:When using multithreading and operating on shared variables, only use thread-safe functions.::PHASE:Implementation:DESCRIPTION:Use atomic operations on shared variables. Be wary of innocent-looking constructs such as x++. This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write.::PHASE:Implementation:DESCRIPTION:Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412.::PHASE:Implementation:DESCRIPTION:Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization.::PHASE:Implementation:DESCRIPTION:Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop.::PHASE:Implementation:DESCRIPTION:Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::",
                "text": "CWE-362 Fixed Code Lines are:"
            }
        ]
    },
    {
        "question": "CWE-682 Code Input Vulnerable Code Is: CWE-682 WORD32 ihevcd_decode ( iv_obj_t * ps_codec_obj , void * pv_api_ip , void * pv_api_op ) { WORD32 ret = IV_SUCCESS ; codec_t * ps_codec = ( codec_t * ) ( ps_codec_obj -> pv_codec_handle ) ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; WORD32 proc_idx = 0 ; WORD32 prev_proc_idx = 0 ; ps_codec -> i4_error_code = 0 ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } if ( ps_codec -> i4_init_done != 1 ) { ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IHEVCD_INIT_NOT_DONE ; return IV_FAIL ; } if ( ps_codec -> u4_pic_cnt >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED ; return IV_FAIL ; } if ( ps_codec -> i4_reset_flag ) { ps_codec -> i4_flush_mode = 1 ; } if ( 0 == ps_codec -> i4_flush_mode ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= MIN_START_CODE_LEN ) { if ( ( WORD32 ) ps_dec_ip -> u4_num_Bytes > 0 ) ps_dec_op -> u4_num_bytes_consumed = ps_dec_ip -> u4_num_Bytes ; else ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } # ifdef APPLY_CONCEALMENT { WORD32",
        "answers": [
            "CWE-682 Fixed Code Lines are: <vul-start> { ps_codec -> <vul-end> pu1_inp_bitsbuf += (\n"
        ],
        "ctxs": [
            {
                "id": "901",
                "title": "CWE-682 Code Input Vulnerable Code Is: 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } # ifdef APPLY_CONCEALMENT { WORD32 num_mbs ; num_mbs = ( ps_codec -> i4_wd * ps_codec -> i4_ht + 255 ) >> 8 ; ps_codec -> mb_count = 0 ; memset ( ps_codec -> mb_map , 0 , ( ( num_mbs + 7 ) >> 3 ) ) ; } # endif if ( 0 == ps_codec -> i4_share_disp_buf && ps_codec -> i4_header_mode == 0 ) { UWORD32 i ; if ( ps_dec_ip -> s_out_buffer . u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec_ip -> s_out_buffer . u4_num_bufs ; i ++ ) { if ( ps_dec_ip -> s_out_buffer . pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> s_out_buffer . u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } ps_codec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_codec -> u4_ts = ps_dec_ip -> u4_ts ; if ( ps_codec -> i4_flush_mode ) { ps_dec_op -> u4_pic_wd = ps_codec -> i4_disp_wd ; ps_dec_op -> u4_pic_ht = ps_codec -> i4_disp_ht ; ps_dec_op -> u4_new_seq = 0 ; ps_codec -> ps_disp_buf = ( pic_buf_t * ) ihevc_disp_mgr_get ( ( disp_mgr_t * ) ps_codec -> pv_disp_buf_mgr , & ps_codec -> i4_disp_buf_id ) ; if ( ( ps_codec -> ps_disp_buf ) && (",
                "text": "CWE-682 Fixed Code Lines are:"
            },
            {
                "id": "902",
                "title": "CWE-682 Code Input Vulnerable Code Is: ) ps_codec -> pv_disp_buf_mgr , & ps_codec -> i4_disp_buf_id ) ; if ( ( ps_codec -> ps_disp_buf ) && ( ( 0 == ps_codec -> i4_share_disp_buf ) || ( IV_YUV_420P == ps_codec -> e_chroma_fmt ) ) ) { process_ctxt_t * ps_proc = & ps_codec -> as_process [ prev_proc_idx ] ; if ( 0 == ps_proc -> i4_init_done ) { ihevcd_init_proc_ctxt ( ps_proc , 0 ) ; } ret = ihevcd_check_out_buf_size ( ps_codec ) ; RETURN_IF ( ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) , ret ) ; ret = ihevcd_fmt_conv ( ps_codec , & ps_codec -> as_process [ prev_proc_idx ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , 0 , ps_codec -> i4_disp_ht ) ; ihevc_buf_mgr_release ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr , ps_codec -> i4_disp_buf_id , BUF_MGR_DISP ) ; } ihevcd_fill_outargs ( ps_codec , ps_dec_ip , ps_dec_op ) ; if ( 1 == ps_dec_op -> u4_output_present ) { WORD32 xpos = ps_codec -> i4_disp_wd - 32 - LOGO_WD ; WORD32 ypos = ps_codec -> i4_disp_ht - 32 - LOGO_HT ; if ( ypos < 0 ) ypos = 0 ; if ( xpos < 0 ) xpos = 0 ; INSERT_LOGO ( ps_dec_ip -> s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_out_buffer . pu1_bufs [ 2 ] , ps_codec -> i4_disp_strd , xpos , ypos , ps_codec -> e_chroma_fmt , ps_codec -> i4_disp_wd , ps_codec -> i4_disp_ht ) ; } if ( NULL == ps_codec -> ps_disp_buf ) { if (",
                "text": "CWE-682 Fixed Code Lines are:"
            },
            {
                "id": "903",
                "title": "CWE-682 Code Input Vulnerable Code Is: -> i4_disp_wd , ps_codec -> i4_disp_ht ) ; } if ( NULL == ps_codec -> ps_disp_buf ) { if ( ps_codec -> i4_reset_flag ) { ihevcd_init ( ps_codec ) ; } return ( IV_FAIL ) ; } return ( IV_SUCCESS ) ; } if ( ( 0 == ps_codec -> i4_header_mode ) && ( 1 == ps_codec -> i4_share_disp_buf ) ) { WORD32 buf_status ; buf_status = 1 ; if ( ps_codec -> pv_pic_buf_mgr ) buf_status = ihevc_buf_mgr_check_free ( ( buf_mgr_t * ) ps_codec -> pv_pic_buf_mgr ) ; if ( 0 == buf_status ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return IV_FAIL ; } } ps_codec -> i4_bytes_remaining = ps_dec_ip -> u4_num_Bytes ; ps_codec -> pu1_inp_bitsbuf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer ; ps_codec -> s_parse . i4_end_of_frame = 0 ; ps_codec -> i4_pic_present = 0 ; ps_codec -> i4_slice_error = 0 ; ps_codec -> ps_disp_buf = NULL ; if ( ps_codec -> i4_num_cores > 1 ) { ithread_set_affinity ( 0 ) ; } while ( MIN_START_CODE_LEN < ps_codec -> i4_bytes_remaining ) { WORD32 nal_len ; WORD32 nal_ofst ; WORD32 bits_len ; if ( ps_codec -> i4_slice_error ) { slice_header_t * ps_slice_hdr_next = ps_codec -> s_parse . ps_slice_hdr_base + ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; WORD32 next_slice_addr = ps_slice_hdr_next -> i2_ctb_x + ps_slice_hdr_next -> i2_ctb_y * ps_codec -> s_parse . ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> s_parse . i4_next_ctb_indx == next_slice_addr ) ps_codec -> i4_slice_error = 0 ; } if ( ps_codec ->",
                "text": "CWE-682 Fixed Code Lines are:"
            },
            {
                "id": "904",
                "title": "CWE-682 Code Input Vulnerable Code Is: -> i4_slice_error = 0 ; } if ( ps_codec ->",
                "text": "CWE-682 Fixed Code Lines are:"
            },
            {
                "id": "902",
                "title": "CWE-682 Code Input AST Vulnerable Code Is: ; (expression_statement, (assignment_expression, (member_access_expression, identifier_ps_codec -> identifier_i4_slice_error ) (assignment_operator, = ) integer_literal_1 ) ; ) (continue_statement, continue_continue ; ) } } if_if ( (binary_expression, identifier_IHEVCD_IGNORE_SLICE == identifier_ret ) ) { (ERROR, < ) (expression_statement, (assignment_expression, (binary_expression, (binary_expression, (assignment_expression, (binary_expression, (binary_expression, identifier_vul - identifier_start ) > (member_access_expression, (member_access_expression, identifier_ps_codec -> identifier_s_parse ) . identifier_i4_cur_slice_idx ) ) (assignment_operator, = ) (invocation_expression, identifier_MAX (argument_list, ( (argument, integer_literal_0 ) , (argument, (parenthesized_expression, ( (binary_expression, (member_access_expression, (member_access_expression, identifier_ps_codec -> identifier_s_parse ) . identifier_i4_cur_slice_idx ) - integer_literal_1 ) ) ) ) ) ) ) ) (ERROR, ; ) < (binary_expression, identifier_vul - identifier_end ) ) > (member_access_expression, identifier_ps_codec -> identifier_pu1_inp_bitsbuf ) ) (assignment_operator, += ) (parenthesized_expression,",
                "text": "CWE-682 Fixed Code Lines are:"
            },
            {
                "id": "903",
                "title": "CWE-682 Code Input AST Vulnerable Code Is: ; ) < (binary_expression, identifier_vul - identifier_end ) ) > (member_access_expression, identifier_ps_codec -> identifier_pu1_inp_bitsbuf ) ) (assignment_operator, += ) (parenthesized_expression, ( (binary_expression, identifier_nal_ofst + identifier_nal_len ) ) ) ) ; ) (member_access_expression, identifier_ps_codec -> identifier_i4_bytes_remaining ) (assignment_operator, -= ) (",
                "text": "CWE-682 Fixed Code Lines are:"
            },
            {
                "id": "0",
                "title": "CWE-682 Code Input Vulnerable Code Is: CWE-682 WORD32 ihevcd_decode ( iv_obj_t * ps_codec_obj , void * pv_api_ip , void * pv_api_op ) { WORD32 ret = IV_SUCCESS ; codec_t * ps_codec = ( codec_t * ) ( ps_codec_obj -> pv_codec_handle ) ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; WORD32 proc_idx = 0 ; WORD32 prev_proc_idx = 0 ; ps_codec -> i4_error_code = 0 ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } if ( ps_codec -> i4_init_done != 1 ) { ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IHEVCD_INIT_NOT_DONE ; return IV_FAIL ; } if ( ps_codec -> u4_pic_cnt >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code |= 1 << IVD_FATALERROR ; ps_dec_op -> u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED ; return IV_FAIL ; } if ( ps_codec -> i4_reset_flag ) { ps_codec -> i4_flush_mode = 1 ; } if ( 0 == ps_codec -> i4_flush_mode ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= MIN_START_CODE_LEN ) { if ( ( WORD32 ) ps_dec_ip -> u4_num_Bytes > 0 ) ps_dec_op -> u4_num_bytes_consumed = ps_dec_ip -> u4_num_Bytes ; else ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } # ifdef APPLY_CONCEALMENT { WORD32",
                "text": "CWE-682 Fixed Code Lines are:"
            },
            {
                "id": "40000",
                "title": "CWE-682 Name: Incorrect Calculation \tDescription: The software performs a calculation that generates incorrect or unintended results that are later used in security-critical decisions or resource management. \tRelated Weaknesses: ::NATURE:CanPrecede:CWE ID:170:VIEW ID:1000:: \tObserved Examples: ::REFERENCE:CVE-2020-0022:DESCRIPTION:chain: mobile phone Bluetooth implementation does not include offset when calculating packet length (CWE-682), leading to out-of-bounds write (CWE-787):LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1363::REFERENCE:CVE-2004-1363:DESCRIPTION:substitution overflow: buffer overflow using environment variables that are expanded after the length check is performed:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-1363:: \tPotential Mitigations: ::PHASE:Implementation:DESCRIPTION:Understand your programming language's underlying representation and how it interacts with numeric calculation. Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, not-a-number calculations, and how your language handles numbers that are too large or too small for its underlying representation.::PHASE:Implementation:STRATEGY:Input Validation:DESCRIPTION:Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.::PHASE:Implementation:DESCRIPTION:Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity.::PHASE:Architecture and Design:STRATEGY:Language Selection:DESCRIPTION:Use languages, libraries, or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++).::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:DESCRIPTION:Use languages, libraries, or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++).::PHASE:Implementation:STRATEGY:Compilation or Build Hardening:DESCRIPTION:Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.::PHASE:Testing:DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.::PHASE:Testing:DESCRIPTION:Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::",
                "text": "CWE-682 Fixed Code Lines are:"
            },
            {
                "id": "10089",
                "title": "CWE-682 Vulnerable Code Is: CWE-682 img_t table_ptr ; int num_imgs ; .. . num_imgs = get_num_imgs ( ) ; <vul-start> table_ptr = ( img_t * ) malloc ( sizeof ( img_t ) * num_imgs ) ; <S2SV_EndBug",
                "text": "CWE-682 Fixed Code Lines are: <vul-start> ) ; if ( num_imgs < = 0 ) { num_imgs = 0 ; } if ( num_imgs > 0 ) { <vul-start> ) ; } else { table_ptr = NULL ; }"
            },
            {
                "id": "10090",
                "title": "CWE-682 Vulnerable Code Is: CWE-682 int * p = x ; <vul-start> char * second_char = ( char * ) ( p + 1 ) ; <S2SV_EndBug",
                "text": "CWE-682 Fixed Code Lines are: <vul-start> * ) ( ( char * )"
            },
            {
                "id": "10012",
                "title": "CWE-190 Vulnerable Code Is: CWE-190 img_t table_ptr ; int num_imgs ; <vul-start> .. . num_imgs = get_num_imgs ( ) ; <vul-end> table_ptr = ( img_t * ) malloc ( sizeof ( img_t ) * num_imgs ) ;",
                "text": "CWE-190 Fixed Code Lines are: <vul-start> ( ) ; if ( num_imgs < = 0 || SIZE_MAX / sizeof ( img_t ) < num_imgs ) { ExitError ( \"Invalid number of images requested!\" ) ; }"
            },
            {
                "id": "10013",
                "title": "CWE-190 Vulnerable Code Is: CWE-190 nresp = packet_get_int ( ) ; <vul-start> if ( nresp > 0 ) { <vul-end> response = xmalloc ( nresp * sizeof ( char * ) ) ; for ( i = 0 ; i < nresp ; i ++ ) response [ i ] = packet_get_string ( NULL ) ; }",
                "text": "CWE-190 Fixed Code Lines are: <vul-start> 0 ) { if ( nresp > SIZE_MAX / sizeof ( char * ) ) { ExitError ( \"Integer overflow occurred!\" ) ; }"
            },
            {
                "id": "10014",
                "title": "CWE-190 Vulnerable Code Is: CWE-190 short int bytesRec = 0 ; char buf [ SOMEBIGNUM ] ; while ( bytesRec < MAXGET ) { <vul-start> bytesRec += getFromInput ( buf + bytesRec ) ; <vul-end> }",
                "text": "CWE-190 Fixed Code Lines are: <vul-start> ) { if ( bytesRec > MAXGET - getFromInput ( buf + bytesRec ) ) { ExitError ( \"Integer overflow occurred!\" ) ; }"
            },
            {
                "id": "10015",
                "title": "CWE-190 Vulnerable Code Is: CWE-190 _StartBug> // #define JAN 1 #define FEB 2 #define MAR 3 short getMonthlySales ( int month ) { <vul-end> .. . } <vul-start> float calculateRevenueForQuarter ( short quarterSold ) { <vul-end> .. . } int determineFirstQuarterRevenue ( ) { float quarterRevenue = 0.0f ; <vul-start> short JanSold = getMonthlySales ( JAN ) ; <vul-end> <vul-start> short FebSold = getMonthlySales ( FEB ) ; <vul-end> <vul-start> short MarSold = getMonthlySales ( MAR ) ; <vul-end> <vul-start> short quarterSold = JanSold + FebSold + MarSold ; <vul-end> quarterRevenue = calculateRevenueForQuarter ( quarterSold ) ; saveFirstQuarterRevenue ( quarterRevenue ) ; return 0 ; }",
                "text": "CWE-190 Fixed Code Lines are: <vul-start> #define MAR 3 int <vul-end> getMonthlySales ( int <vul-start> float calculateRevenueForQuarter ( int <vul-end> quarterSold ) { <vul-start> 0.0f ; int <vul-end> JanSold = getMonthlySales <vul-start> ) ; int <vul-end> FebSold = getMonthlySales <vul-start> ) ; int <vul-end> MarSold = getMonthlySales <vul-start> ) ; int <vul-end> quarterSold = JanSold"
            },
            {
                "id": "10042",
                "title": "CWE-369 Vulnerable Code Is: CWE-369 double divide ( double x , double y ) { <vul-start> return x / y ; <vul-end> }",
                "text": "CWE-369 Fixed Code Lines are: <vul-start> ) { if ( 0 == y ) { throw DivideByZero ; }"
            },
            {
                "id": "10043",
                "title": "CWE-369 Vulnerable Code Is: CWE-369 _StartBug> // int SafeDivision ( int x , int y ) { <vul-end> return ( x / y ) ; <vul-start> } <S2SV_EndBug",
                "text": "CWE-369 Fixed Code Lines are: <vul-start> int y ) { try <vul-start> } catch ( System . DivideByZeroException dbz ) { System . Console . WriteLine ( \"Division by zero attempted!\" ) ; return 0 ; } }"
            },
            {
                "id": "10079",
                "title": "CWE-191 Vulnerable Code Is: CWE-191 #include #include int main ( void ) { <vul-start> int i ; <vul-end> <vul-start> i = - 2147483648 ; <vul-end> i = i - 1 ; return 0 ; }",
                "text": "CWE-191 Fixed Code Lines are: <vul-start> ) { unsigned <vul-start> i = 0x80000000 <vul-end> ; i"
            },
            {
                "id": "10080",
                "title": "CWE-191 Vulnerable Code Is: CWE-191 #include #include int main ( void ) { int a = 5 , b = 6 ; <vul-start> size_t len = a - b ; <vul-end> char buf [ len ] ; <vul-start> return 0 ; <vul-end> }",
                "text": "CWE-191 Fixed Code Lines are: <vul-start> size_t len = ( a >= b ) ? ( <vul-start> a - b ) : 0 ; if ( len > 0 ) { <vul-end> char buf <vul-start> ] ; } else { }"
            },
            {
                "id": "10100",
                "title": "CWE-193 Vulnerable Code Is: CWE-193 int i ; unsigned int numWidgets ; Widget * * WidgetList ; numWidgets = GetUntrustedSizeValue ( ) ; if ( ( numWidgets == 0 ) || ( numWidgets > MAX_NUM_WIDGETS ) ) { ExitError ( \"Incorrect number of widgets requested!\" ) ; } <vul-start> printf ( \" WidgetList ptr = % p \\n \" for ( i = 0 ; <vul-end> i < numWidgets ; i ++ ) { WidgetList [ i ] = InitializeWidget ( ) ; } <vul-start> showWidgets ( WidgetList ) ; <S2SV_EndBug",
                "text": "CWE-193 Fixed Code Lines are: <vul-start> } WidgetList = ( Widget * * ) malloc ( ( numWidgets + 1 ) * sizeof ( Widget * ) ) ; <vul-start> } WidgetList [ numWidgets ] = NULL ; <vul-start> ( WidgetList ) <vul-end> ;"
            },
            {
                "id": "10101",
                "title": "CWE-193 Vulnerable Code Is: CWE-193 char firstname [ 20 ] ; char lastname [ 20 ] ; char fullname [ 40 ] ; fullname [ 0 ] = '\\0' ; <vul-start> strncat ( fullname , firstname , 20 ) ; <vul-end> <vul-start> strncat ( fullname , lastname , 20 ) ; <S2SV_EndBug",
                "text": "CWE-193 Fixed Code Lines are: <vul-start> , firstname , sizeof ( fullname ) - strlen ( fullname ) - 1 <vul-end> ) ; <vul-start> , lastname , sizeof ( fullname ) - strlen ( fullname ) - 1 <vul-end> ) ;"
            }
        ]
    }
]